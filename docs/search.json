[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Baden-520-Blog",
    "section": "",
    "text": "Some Ice Sport Doohickey\n\n\n\n\n\n\nNuh uh\n\n\n\n\n\n\n\n\n\nIan\n\n\n\n\n\n\n\n\n\n\n\n\nMarks and Channels\n\n\n\n\n\n\nMarks and Channels\n\n\n\n\n\n\n\n\n\nIan\n\n\n\n\n\n\n\n\n\n\n\n\nIt me\n\n\n\n\n\n\nfuny\n\n\n\n\n\n\n\n\n\nIan\n\n\n\n\n\n\n\n\n\n\n\n\nActions and Targets\n\n\n\n\n\n\nActions and Targets\n\n\n\n\n\n\n\n\n\nFeb 19, 2025\n\n\nIan\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nwhat\n\n\n\n\n\n\n\n\n\nFeb 13, 2025\n\n\nIan\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "It me",
    "section": "",
    "text": "This is a post with executable code (maybe)\nFun youtube video: https://www.youtube.com/watch?v=dQw4w9WgXcQ\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\n\nx = np.array([10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5])\ny1 = np.array([8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68])\ny2 = np.array([9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74])\ny3 = np.array([7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73])\nx4 = np.array([8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8])\ny4 = np.array([6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89])\n\nxmean=np.mean(x)\nx4mean=np.mean(x4)\ny1var=statistics.variance(y1)\ny2var=statistics.variance(y2)\ny3var=statistics.variance(y3)\ny4var=statistics.variance(y4)\ny1mean=np.mean(y1)\ny2mean=np.mean(y2)\ny3mean=np.mean(y3)\ny4mean=np.mean(y4)\n\ndata = {'Set':[1,2,3,4], \n        'X Mean': [x4mean, x4mean, x4mean, x4mean], \n        'Y Variances': [y1var,y2var,y3var,y4var], \n        'Y Means':[y1mean,y2mean,y3mean,y4mean]}\ndf = pd.DataFrame(data)\n#print(df)\n\n#Regressions\nm1,b1=np.polyfit(x,y1,1)\nm2,b2=np.polyfit(x,y2,1)\nm3,b3=np.polyfit(x,y3,1)\nm4,b4=np.polyfit(x4,y4,1)\nxl=np.arange(20)\n\nplt.subplot(2,2,1)\nplt.plot(x,y1,'.',c=\"blue\",label=r'$\\mu$ = 7.5')\nplt.plot(x,y1,'.',c=\"blue\",label=r'$\\sigma ^2$ = 4.127')\nplt.plot(x,m1*x+b1,color='red')\nplt.legend(loc=\"lower right\")\nplt.ylim(4, 11)\nplt.show()\nplt.subplot(2,2,2)\nplt.plot(x,y2,'.',c=\"blue\",label=r'$\\mu$ = 7.5')\nplt.plot(x,y2,'.',c=\"blue\",label=r'$\\sigma ^2$ = 4.127')\nplt.plot(x,m2*x+b2,color='red')\nplt.legend(loc=\"lower right\")\nplt.ylim(4, 11)\nplt.show()\nplt.subplot(2,2,3)\nplt.plot(x,y3,'.',c=\"blue\",label=r'$\\mu$ = 7.5')\nplt.plot(x,y3,'.',c=\"blue\",label=r'$\\sigma ^2$ = 4.123')\nplt.plot(x,m3*x+b3,color='red')\nplt.legend(loc=\"lower right\")\nplt.ylim(4, 11)\nplt.show()\nplt.subplot(2,2,4)\nplt.xlim(7,20)\nplt.plot(x4,y4,'.',c=\"blue\",label=r'$\\mu$ = 7.5')\nplt.plot(x4,y4,'.',c=\"blue\",label=r'$\\sigma ^2$ = 4.123')\nplt.plot(0.4999*xl+3.0017,color='red')\nplt.legend(loc=\"lower right\")\nplt.ylim(5, 13)\nplt.show()\n\npd.melt(df, id_vars=None, value_vars=None, var_name=None, value_name='value', col_level=None, ignore_index=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvariable\nvalue\n\n\n\n\n0\nSet\n1.000000\n\n\n1\nSet\n2.000000\n\n\n2\nSet\n3.000000\n\n\n3\nSet\n4.000000\n\n\n4\nX Mean\n9.000000\n\n\n5\nX Mean\n9.000000\n\n\n6\nX Mean\n9.000000\n\n\n7\nX Mean\n9.000000\n\n\n8\nY Variances\n4.127269\n\n\n9\nY Variances\n4.127629\n\n\n10\nY Variances\n4.122620\n\n\n11\nY Variances\n4.123249\n\n\n12\nY Means\n7.500909\n\n\n13\nY Means\n7.500909\n\n\n14\nY Means\n7.500000\n\n\n15\nY Means\n7.500909"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog This is nothing more than an attempt to create a blog in quarto at this moment"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image is here."
  },
  {
    "objectID": "posts/actions-and-targets/Assignment3.html",
    "href": "posts/actions-and-targets/Assignment3.html",
    "title": "Actions and Targets",
    "section": "",
    "text": "title: This will be a basic demonstration of different visuals to represent data. THe dataset chosen is going to be electoral results from the 2002 German federal election. Each of the main parties’ results were taken and analyzed at a Bundesland (State) level and then visualized both independently and in common spaces. The following data are from 2002 wherein the SPD (Social Democratic Party of Germany) and the Greens won the election as a coalition and remained in power. An important thing to note is that elections in the Bundestag work differently than the US. The system over there has a plurality of political parties, with no one party maintaining dominance over others. This often results in different parties needing to form coalitions with each other in order to win elections and rule the country with the largest party of the coalition usually being the one whose leader becomes Kanzler or Kanzlerin. jupyter: python3\n\n\nLet’s begin with this foray into data visualization. Sections below will have German as comments that will split each section that describe the data in them. The Bundestag Sitzplaetze section contains the number of Bundestag seats each party had out of the total seats that it had that year. Sections beneath will report the results for each party by Bundesland and by percent of the votes of that Bundesland that they won.\n\n\nOne last important detail before getting to code and visualizations is the clarification of potential action-target pairs present in this post. The desired action here is for viewers to analyze and consume trends and outliers present in the 2002 german election. Another desired action is for viewers to identify and compare attributes of the election like the location of party strongholds and distributions of where certain parties were most successful.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\n\n\n\n2002 Bundestag sitzplaetze resultaten\n\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\n\n\nResultaten Fuer SPD 2002 bei Bundesland in prozent\n\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\n\n\nResultaten fuer Union (UN) 2002 bei Bundesland in prozent\n\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\n\n\nResultaten fuer Buendnis/Die Gruene 2002 bei Bundesland in prozent\n\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\n\n\nResultaten fuer FDP 2002 bei Bundesland in Prozent\n\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\n\n\nResultaten fuer PDS 2002 bei Bundesland in Prozent\n\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\n\n\nBundesland results by Bundesland comparing the votes percentages each party got in that Bundesland.\n\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\n\nWhat follows next will be a set of visualizations for the data from above. The first bar graph beneath will include all of the parties results for each Bundesland stacked next to each other for that specific Bundesland. An important side note is that abbreviations are used in the legend. The main ones that may be confusing are the BG90 and Union parties. BG90 is short for Buendnis 90/Die Gruene, this is party are the Greens. Union on the other hand is a coalition between the CSU and CDU parties which are centre right political parties.\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,3, 5, 7,9, 11, 13, 15,17, 19, 21, 23,25, 27, 29, 31]);\nplt.bar(Laender -0.1, SPD02DE, 0.4, label = 'SPD',color='red') \nplt.bar(Laender - 0.5, UN02DE, 0.4, label = 'Union',color='black') \nplt.bar(Laender - 0.9, BG02DE, 0.4, label = 'BG90',color='green') \nplt.bar(Laender + 0.3, FDP02DE, 0.4, label = 'FDP',color='#FFFF00') \nplt.bar(Laender + 0.8, PDS02DE, 0.4, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nNext will be a bar graph just like above, except the parties’ results are overlaid on to one another. Both of these bar graphs will be pertinent in a future post regarding marks and channels used in visualizations.\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, SPD02DE, label = 'SPD',color='red') \nplt.bar(Laender, UN02DE, label = 'Union',color='black') \nplt.bar(Laender, BG02DE, label = 'SPDE',color='green') \nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.bar(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nBeneath will be a set of bar grpahs that present the results for individual parties in each Bundesland in Germany. The first will be the winning party, SPD.\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, SPD02DE, label = 'SPD',color='red') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 SPD Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nNext will be the Union party\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, UN02DE, label = 'Union',color='black') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 Union Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nResults for Buendnis 90/ Die Gruene\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, BG02DE, label = 'BG90',color='green') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 BG90 Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nThe bar graph beneath for the FDP in 2002 is an important lesson in choosing colors wisely when presenting data. In the form directly beneath, the yellow on top of white is glaringly bright and makes distinction of votes percentages far more difficult.\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nInstead, let’s change the background to blue with an unintended consequence that it now looks like a very poorly done offbrand ikea illustration. However, with the blue background the ability to determine the percentage that the SPD earned in each state is much easier. I did try using black but very quickly realized that black made it very difficult to see where the percentages are as well.\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nax = plt.gca()  \n# Setting Background colour yellow \nax.set_facecolor(\"blue\")\nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\nBeneath will be the final party of 2002 being looked at, the PDS who have since renamed to Die Linke (The Left).\n\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 PDS Election Results\") \nplt.legend() \nplt.show()"
  },
  {
    "objectID": "posts/actions-and-targets/Index.html",
    "href": "posts/actions-and-targets/Index.html",
    "title": "Actions and Targets",
    "section": "",
    "text": "This will be a basic demonstration of different visuals to represent data. The dataset chosen is going to be electoral results from the 2002 German federal election. Each of the main parties’ results were taken and analyzed at a Bundesland (State) level and then visualized both independently and in common spaces. The following data are from 2002 wherein the SPD (Social Democratic Party of Germany) and the Greens won the election as a coalition and remained in power. An important thing to note is that elections in the Bundestag work differently than the US. The system over there has a plurality of political parties, with no one party maintaining dominance over others. This often results in different parties needing to form coalitions with each other in order to win elections and rule the country with the largest party of the coalition usually being the one whose leader becomes Kanzler or Kanzlerin.\nLet’s begin with this foray into data visualization. Sections below will have German as comments that will split each section that describe the data in them. The Bundestag Sitzplaetze section contains the number of Bundestag seats each party had out of the total seats that it had that year. Sections beneath will report the results for each party by Bundesland and by percent of the votes of that Bundesland that they won.\nOne last important detail before getting to code and visualizations is the clarification of potential action-target pairs present in this post. The desired action here is for viewers to analyze and consume trends and outliers present in the 2002 german election. Another desired action is for viewers to identify and compare attributes of the election like the location of party strongholds and distributions of where certain parties were most successful.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\n\n\n2002 Bundestag sitzplaetze resultaten\n\n\nCode\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\n\nResultaten Fuer SPD 2002 bei Bundesland in prozent\n\n\nCode\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\n\nResultaten fuer Union (UN) 2002 bei Bundesland in prozent\n\n\nCode\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\n\nResultaten fuer Buendnis/Die Gruene 2002 bei Bundesland in prozent\n\n\nCode\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\n\nResultaten fuer FDP 2002 bei Bundesland in Prozent\n\n\nCode\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\n\nResultaten fuer PDS 2002 bei Bundesland in Prozent\n\n\nCode\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\n\nBundesland results by Bundesland comparing the votes percentages each party got in that Bundesland.\n\n\nCode\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\nWhat follows next will be a set of visualizations for the data from above. The first bar graph beneath will include all of the parties results for each Bundesland stacked next to each other for that specific Bundesland. An important side note is that abbreviations are used in the legend. The main ones that may be confusing are the BG90 and Union parties. BG90 is short for Buendnis 90/Die Gruene, this is party are the Greens. Union on the other hand is a coalition between the CSU and CDU parties which are centre right political parties.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,3, 5, 7,9, 11, 13, 15,17, 19, 21, 23,25, 27, 29, 31]);\nplt.bar(Laender -0.1, SPD02DE, 0.4, label = 'SPD',color='red') \nplt.bar(Laender - 0.5, UN02DE, 0.4, label = 'Union',color='black') \nplt.bar(Laender - 0.9, BG02DE, 0.4, label = 'BG90',color='green') \nplt.bar(Laender + 0.3, FDP02DE, 0.4, label = 'FDP',color='#FFFF00') \nplt.bar(Laender + 0.8, PDS02DE, 0.4, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nNext will be a bar graph just like above, except the parties’ results are overlaid on to one another. Both of these bar graphs will be pertinent in a future post regarding marks and channels used in visualizations.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, SPD02DE, label = 'SPD',color='red') \nplt.bar(Laender, UN02DE, label = 'Union',color='black') \nplt.bar(Laender, BG02DE, label = 'SPDE',color='green') \nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.bar(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nBeneath will be a set of bar grpahs that present the results for individual parties in each Bundesland in Germany. The first will be the winning party, SPD.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, SPD02DE, label = 'SPD',color='red') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 SPD Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nNext will be the Union party\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, UN02DE, label = 'Union',color='black') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 Union Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nResults for Buendnis 90/ Die Gruene\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, BG02DE, label = 'BG90',color='green') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 BG90 Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nThe bar graph beneath for the FDP in 2002 is an important lesson in choosing colors wisely when presenting data. In the form directly beneath, the yellow on top of white is glaringly bright and makes distinction of votes percentages far more difficult.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nInstead, let’s change the background to blue with an unintended consequence that it now looks like a very poorly done offbrand ikea illustration. However, with the blue background the ability to determine the percentage that the SPD earned in each state is much easier. I did try using black but very quickly realized that black made it very difficult to see where the percentages are as well.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nax = plt.gca()  \nax.set_facecolor(\"blue\")\nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nBeneath will be the final party of 2002 being looked at, the PDS who have since renamed to Die Linke (The Left).\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 PDS Election Results\") \nplt.legend() \nplt.show()"
  },
  {
    "objectID": "posts/marks-and-channels/MNC.html",
    "href": "posts/marks-and-channels/MNC.html",
    "title": "Marks and Channels",
    "section": "",
    "text": "‘This is going to be a great time. It is time to create miserable combinations of marks and channels. However, what are marks and channels? Marks are the items of a data, in my case they are the percentages of votes that each party got. Channels are the appearance of marks. Think things like color, shape, size, etc.’\nLet us skip all the boring code since it is all going to eb recycled from the last post.’\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\n\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\n‘Now begins the interesting part of trying to make the worst visualizations possible which may be surprisingly difficult. To begin with, I shall do a rerun of the very garishly bright FDP bar graph.’\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\n\n\nCode\n'Very gelb much wow. Next, I shall make a connected scatter plot of all the data for the 2002 election to create an excellent mess.'\n\n\n'Very gelb much wow. Next, I shall make a connected scatter plot of all the data for the 2002 election to create an excellent mess.'\n\n\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.plot(Laender, SPD02DE, label = 'SPD',color='red') \nplt.plot(Laender, UN02DE, label = 'Union',color='black') \nplt.plot(Laender, BG02DE, label = 'SPDE',color='green') \nplt.plot(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.plot(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.legend(loc='right')\nplt.show() \n\n\n\n\n\n\n\n\n\n\n\nCode\n'Maybe I will try a hexplot next for union 2002. It is a mess and does nothing to help convey information for people to discover trends or be able to identify strongholds of the party.'\n\n\n'Maybe I will try a hexplot next for union 2002. It is a mess and does nothing to help convey information for people to discover trends or be able to identify strongholds of the party.'\n\n\n\n\nCode\nplt.style.use('_mpl-gallery-nogrid')\n\nfig, ax = plt.subplots()\n\nax.hexbin(Laender, UN02DE, gridsize=20)\n\nax.set(xlim=(0,20), ylim=(20,60))\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n'The next plot will be a box plot that shows the whole datasets for each party across all different geogrpahic boundaries. Except, this will not show geographic boundaries, it will shows minimum and maximum vote percentages with an unknown confidence interval. Have fun determining which  states are where within this box plot.'\n\n\n'The next plot will be a box plot that shows the whole datasets for each party across all different geogrpahic boundaries. Except, this will not show geographic boundaries, it will shows minimum and maximum vote percentages with an unknown confidence interval. Have fun determining which  states are where within this box plot.'\n\n\n\n\nCode\nlabels=['SPD','UN','BG','FDP','PDS']\ncolors=['red','black','green','#FFFF00','#A2142F']\n\nELplot=plt.boxplot([SPD02DE,UN02DE,BG02DE,FDP02DE,PDS02DE],patch_artist=\"true\",tick_labels=labels)\nplt.xticks=([1,2,3,4,5], ['SPD02DE','UN02DE','BG02DE','FDP02DE','PDS02DE'])\nfor patch, color in zip(ELplot['boxes'], colors):\n    patch.set_facecolor(color)\nplt.show()"
  },
  {
    "objectID": "posts/marks-and-channels/MNC1.html",
    "href": "posts/marks-and-channels/MNC1.html",
    "title": "Marks and Channels",
    "section": "",
    "text": "This is going to be a great time. It is time to create miserable combinations of marks and channels. However, what are marks and channels? Marks are the items of a data, in my case they are the percentages of votes that each party got. Channels are the appearance of marks. Think things like color, shape, size, etc.\nLet us skip all the boring code since it is all going to eb recycled from the last post.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\n\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\nNow begins the interesting part of trying to make the worst visualizations possible which may be surprisingly difficult. To begin with, I shall do a rerun of the very garishly bright FDP bar graph\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nVery yellow much wow. Next, I shall make a connected scatter plot of all the data for the 2002 election to create an excellent mess.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.plot(Laender, SPD02DE, label = 'SPD',color='red') \nplt.plot(Laender, UN02DE, label = 'Union',color='black') \nplt.plot(Laender, BG02DE, label = 'SPDE',color='green') \nplt.plot(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.plot(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.legend(loc='right')\nplt.show() \n\n\n\n\n\n\n\n\n\nMaybe I will try a hexplot next for union 2002. It is a mess and does nothing to help convey information for people to discover trends or be able to identify strongholds of the party.\n\n\nCode\nplt.style.use('_mpl-gallery-nogrid')\n\nfig, ax = plt.subplots()\n\nax.hexbin(Laender, UN02DE, gridsize=20)\n\nax.set(xlim=(0,20), ylim=(20,60))\n\nplt.show()\n\n\n\n\n\n\n\n\n\nThe next plot will be a box plot that shows the whole datasets for each party across all different geogrpahic boundaries. Except, this will not show geographic boundaries, it’ll shows minimum and maximum vote percentages with an unknown confidence interval. Have fun determining which states are where within this box plot.\n\n\nCode\nlabels=['SPD','UN','BG','FDP','PDS']\ncolors=['red','black','green','#FFFF00','#A2142F']\n\nELplot=plt.boxplot([SPD02DE,UN02DE,BG02DE,FDP02DE,PDS02DE],patch_artist=\"true\",tick_labels=labels)\nplt.xticks=([1,2,3,4,5], ['SPD02DE','UN02DE','BG02DE','FDP02DE','PDS02DE'])\nfor patch, color in zip(ELplot['boxes'], colors):\n    patch.set_facecolor(color)\nplt.show()"
  },
  {
    "objectID": "MNC1.html",
    "href": "MNC1.html",
    "title": "Marks and Channels",
    "section": "",
    "text": "This is going to be a great time. It is time to create miserable combinations of marks and channels. However, what are marks and channels? Marks are the items of a data, in my case they are the percentages of votes that each party got. Channels are the appearance of marks. Think things like color, shape, size, etc.\nLet us skip all the boring code since it is all going to eb recycled from the last post.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\n\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\nNow begins the interesting part of trying to make the worst visualizations possible which may be surprisingly difficult. To begin with, I shall do a rerun of the very garishly bright FDP bar graph\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nVery yellow much wow. Next, I shall make a connected scatter plot of all the data for the 2002 election to create an excellent mess.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.plot(Laender, SPD02DE, label = 'SPD',color='red') \nplt.plot(Laender, UN02DE, label = 'Union',color='black') \nplt.plot(Laender, BG02DE, label = 'SPDE',color='green') \nplt.plot(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.plot(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.legend(loc='right')\nplt.show() \n\n\n\n\n\n\n\n\n\nMaybe I will try a hexplot next for union 2002. It is a mess and does nothing to help convey information for people to discover trends or be able to identify strongholds of the party.\n\n\nCode\nplt.style.use('_mpl-gallery-nogrid')\n\nfig, ax = plt.subplots()\n\nax.hexbin(Laender, UN02DE, gridsize=20)\n\nax.set(xlim=(0,20), ylim=(20,60))\n\nplt.show()\n\n\n\n\n\n\n\n\n\nThe next plot will be a box plot that shows the whole datasets for each party across all different geogrpahic boundaries. Except, this will not show geographic boundaries, it’ll shows minimum and maximum vote percentages with an unknown confidence interval. Have fun determining which states are where within this box plot.\n\n\nCode\nlabels=['SPD','UN','BG','FDP','PDS']\ncolors=['red','black','green','#FFFF00','#A2142F']\n\nELplot=plt.boxplot([SPD02DE,UN02DE,BG02DE,FDP02DE,PDS02DE],patch_artist=\"true\",tick_labels=labels)\nplt.xticks=([1,2,3,4,5], ['SPD02DE','UN02DE','BG02DE','FDP02DE','PDS02DE'])\nfor patch, color in zip(ELplot['boxes'], colors):\n    patch.set_facecolor(color)\nplt.show()"
  },
  {
    "objectID": "posts/marks-and-channels/MNC2.html",
    "href": "posts/marks-and-channels/MNC2.html",
    "title": "Marks and Channels",
    "section": "",
    "text": "This is going to be a great time. It is time to create miserable combinations of marks and channels. However, what are marks and channels? Marks are the items of a data, in my case they are the percentages of votes that each party got. Channels are the appearance of marks. Think things like color, shape, size, etc.\nLet us skip all the boring code since it is all going to eb recycled from the last post.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\nfrom matplotlib import cm\n\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\nNow begins the interesting part of trying to make the worst visualizations possible which may be surprisingly difficult. To begin with, I shall do a rerun of the very garishly bright FDP bar graph\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nVery yellow much wow. Next, I shall make a connected scatter plot of all the data for the 2002 election to create an excellent mess.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.plot(Laender, SPD02DE, label = 'SPD',color='red') \nplt.plot(Laender, UN02DE, label = 'Union',color='black') \nplt.plot(Laender, BG02DE, label = 'SPDE',color='green') \nplt.plot(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.plot(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.legend(loc='right')\nplt.show() \n\n\n\n\n\n\n\n\n\nMaybe I will try a hexplot next for union 2002. It is a mess and does nothing to help convey information for people to discover trends or be able to identify strongholds of the party.\n\n\nCode\nplt.style.use('_mpl-gallery-nogrid')\n\nfig, ax = plt.subplots()\n\nax.hexbin(Laender, UN02DE, gridsize=20)\n\nax.set(xlim=(0,20), ylim=(20,60))\n\nplt.show()\n\n\n\n\n\n\n\n\n\nThe next plot will be a box plot that shows the whole datasets for each party across all different geogrpahic boundaries. Except, this will not show geographic boundaries, it’ll show minimum and maximum vote percentages with an unknown confidence interval. Have fun determining which states are where within this box plot.\n\n\nCode\nlabels=['SPD','UN','BG','FDP','PDS']\ncolors=['red','black','green','#FFFF00','#A2142F']\n\nELplot=plt.boxplot([SPD02DE,UN02DE,BG02DE,FDP02DE,PDS02DE],patch_artist=\"true\",tick_labels=labels)\nplt.xticks=([1,2,3,4,5], ['SPD02DE','UN02DE','BG02DE','FDP02DE','PDS02DE'])\nfor patch, color in zip(ELplot['boxes'], colors):\n    patch.set_facecolor(color)\nplt.show()\n\n\n\n\n\n\n\n\n\nAlso, there is a favorite one of my experiments in data visuzliation I will add back in here\nThe following plots are attempts to recreate my matlab surface plots. These plots are inevitable Dr. Robison.\n\n\nCode\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n# Plot the surface.\nFDP02DE2=FDP02DE.reshape(4,4)\ny=np.array([4,3,2,1]);\nx=np.array([1,2,3,4]);\n#surf(x,y,SPD02DE,'LineStyle',\":\")\nplt.ylabel('South-North')\nplt.xlabel('East-West')\n#plt.zlabel('Votes in %')\nplt.title('Surface Map of FDP Votes in DE 2002')\nsurf = ax.plot_surface(x, y, FDP02DE2, cmap=cm.coolwarm,linewidth=0, antialiased=False)\nax.view_init(-170, 45)\n#ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n# Plot the surface.\nPDS02DE2=PDS02DE.reshape(4,4)\ny=np.array([4,3,2,1]);\nx=np.array([1,2,3,4]);\n#surf(x,y,SPD02DE,'LineStyle',\":\")\nplt.ylabel('South-North')\nplt.xlabel('East-West')\n#plt.zlabel('Votes in %')\nplt.title('Surface Map of PDS Votes in DE 2002')\nsurf = ax.plot_surface(x, y, PDS02DE2, cmap=cm.coolwarm,linewidth=0, antialiased=False)\nax.view_init(-150, 45)\n#ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n# Plot the surface.\nUN02DE2=UN02DE.reshape(4,4)\ny=np.array([4,3,2,1]);\nx=np.array([1,2,3,4]);\n#surf(x,y,SPD02DE,'LineStyle',\":\")\nplt.ylabel('South-North')\nplt.xlabel('East-West')\n#plt.zlabel('Votes in %')\nplt.title('Surface Map of PDS Votes in DE 2002')\nsurf = ax.plot_surface(x, y, UN02DE2, cmap=cm.coolwarm,linewidth=0, antialiased=False)\nax.view_init(-150, 45)\n#ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)"
  },
  {
    "objectID": "posts/MNC-take-2/MNC2.html",
    "href": "posts/MNC-take-2/MNC2.html",
    "title": "Marks and Channels",
    "section": "",
    "text": "This is going to be a great time. It is time to create miserable combinations of marks and channels. However, what are marks and channels? Marks are the items of a data, in my case they are the percentages of votes that each party got. Channels are the appearance of marks. Think things like color, shape, size, etc.\nLet us skip all the boring code since it is all going to eb recycled from the last post.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport statistics\nfrom matplotlib import cm\n\nSPD02 = 251/603;\nCDU02 = 190/603;\nCSU02 = 58/603;\nBund02 = 55/603;\nFDP02 = 47/603;\nPDS02 = 2/603;\nUnion02=CDU02+CSU02;\n\nSPD02MV = 41.7;\nSPD02SH = 42.9;\nSPD02HM = 42;\nSPD02BR = 48.6;\nSPD02BL = 36.6;\nSPD02BB = 46.4;\nSPD02SA = 43.2;\nSPD02NS = 47.8;\nSPD02SN = 33.3;\nSPD02TH = 39.9;\nSPD02HN = 39.7;\nSPD02NW = 43;\nSPD02BY = 26.1;\nSPD02BW = 33.5;\nSPD02RP = 38.2;\nSPD02SL = 46;\nSPD02DE = np.array([SPD02MV,SPD02SH,SPD02HM,SPD02BR,SPD02BL,SPD02BB,SPD02SA,SPD02NS,SPD02SN,SPD02TH,SPD02HN,SPD02NW,SPD02BY,SPD02BW,SPD02RP,SPD02SL]);\n\nUN02MV = 30.3;\nUN02SH = 36;\nUN02HM = 42;\nUN02BR = 24.6;\nUN02BL = 25.9;\nUN02BB = 22.3;\nUN02SA = 29;\nUN02NS = 34.5;\nUN02SN = 33.6;\nUN02TH = 29.4;\nUN02HN = 37.1;\nUN02NW = 35.1;\nUN02BY = 58.6;\nUN02BW = 42.8;\nUN02RP = 40.3;\nUN02SL = 35;\nUN02DE = np.array([UN02MV,UN02SH,UN02HM,UN02BR,UN02BL,UN02BB,UN02SA,UN02NS,UN02SN,UN02TH,UN02HN,UN02NW,UN02BY,UN02BW,UN02RP,UN02SL]);\n\nBG02MV = 3.5;\nBG02SH = 9.4;\nBG02HM = 16.2;\nBG02BR = 15;\nBG02BL = 14.6;\nBG02BB = 4.5;\nBG02SA = 3.4;\nBG02NS = 7.3;\nBG02SN = 4.6;\nBG02TH = 4.3;\nBG02HN = 10.7;\nBG02NW = 8.9;\nBG02BY = 7.6;\nBG02BW = 11.4;\nBG02RP = 7.9;\nBG02SL = 7.6;\nBG02DE = np.array([BG02MV,BG02SH,BG02HM,BG02BR,BG02BL,BG02BB,BG02SA,BG02NS,BG02SN,BG02TH,BG02HN,BG02NW,BG02BY,BG02BW,BG02RP,BG02SL]);\n\nFDP02MV = 5.4;\nFDP02SH = 8;\nFDP02HM = 6.8;\nFDP02BR = 6.7;\nFDP02BL = 6.6;\nFDP02BB = 5.8;\nFDP02SA = 7.6;\nFDP02NS = 7.1;\nFDP02SN = 7.3;\nFDP02TH = 5.9;\nFDP02HN = 8.2;\nFDP02NW = 9.4;\nFDP02BY = 4.5;\nFDP02BW = 7.8;\nFDP02RP = 9.3;\nFDP02SL = 6.4;\nFDP02DE = np.array([FDP02MV,FDP02SH,FDP02HM,FDP02BR,FDP02BL,FDP02BB,FDP02SA,FDP02NS,FDP02SN,FDP02TH,FDP02HN,FDP02NW,FDP02BY,FDP02BW,FDP02RP,FDP02SL]);\n\nPDS02MV = 16.3;\nPDS02SH = 1.3;\nPDS02HM = 2.1;\nPDS02BR = 2.2;\nPDS02BL = 11.4;\nPDS02BB = 17.2;\nPDS02SA = 14.4;\nPDS02NS = 1;\nPDS02SN = 16.2;\nPDS02TH = 17;\nPDS02HN = 1.3;\nPDS02NW = 1.2;\nPDS02BY = 0.7;\nPDS02BW = 1;\nPDS02RP = 1;\nPDS02SL = 1.4;\nPDS02DE = np.array([PDS02MV,PDS02SH,PDS02HM,PDS02BR,PDS02BL,PDS02BB,PDS02SA,PDS02NS,PDS02SN,PDS02TH,PDS02HN,PDS02NW,PDS02BY,PDS02BW,PDS02RP,PDS02SL]);\n\nMV02 = np.array([SPD02MV, UN02MV,BG02MV,FDP02MV,PDS02MV]);\nSH02 = np.array([SPD02SH, UN02SH,BG02SH,FDP02SH,PDS02SH]);\nHM02 = np.array([SPD02HM, UN02HM,BG02HM,FDP02HM,PDS02HM]);\nBR02 = np.array([SPD02BR, UN02BR,BG02BR,FDP02BR,PDS02BR]);\nBL02 = np.array([SPD02BL, UN02BL,BG02BL,FDP02BL,PDS02BL]);\nBB02 = np.array([SPD02BB, UN02BB,BG02BB,FDP02BB,PDS02BB]);\nSA02 = np.array([SPD02SA, UN02SA,BG02SA,FDP02SA,PDS02SA]);\nNS02 = np.array([SPD02NS, UN02NS,BG02NS,FDP02NS,PDS02NS]);\nSN02 = np.array([SPD02SN, UN02SN,BG02SN,FDP02SN,PDS02SN]);\nTH02 = np.array([SPD02TH, UN02TH,BG02TH,FDP02TH,PDS02TH]);\nHN02 = np.array([SPD02HN, UN02HN,BG02HN,FDP02HN,PDS02HN]);\nNW02 = np.array([SPD02NW, UN02NW,BG02NW,FDP02NW,PDS02NW]);\nBY02 = np.array([SPD02BY, UN02BY,BG02BY,FDP02BY,PDS02BY]);\nBW02 = np.array([SPD02BW, UN02BW,BG02BW,FDP02BW,PDS02BW]);\nRP02 = np.array([SPD02RP, UN02RP,BG02RP,FDP02RP,PDS02RP]);\nSL02 = np.array([SPD02SL, UN02SL,BG02SL,FDP02SL,PDS02SL]);\n\n\nNow begins the interesting part of trying to make the worst visualizations possible which may be surprisingly difficult. To begin with, I shall do a rerun of the very garishly bright FDP bar graph\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.bar(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"bundeslaender\") \nplt.title(\"2002 FDP Election Results\") \nplt.legend() \nplt.show() \n\n\n\n\n\n\n\n\n\nVery yellow much wow. Next, I shall make a connected scatter plot of all the data for the 2002 election to create an excellent mess.\n\n\nCode\nBundeslaender = np.array(['Mecklenburg-Vorpommern','Schleswig Holstein','Hamburg','Bremen','Berlin','Brandenburg','Sachsen-Anhalt','Niedersachsen','Sachsen','Thueringen','Hessen','Nordrhein-Westfalen','Bayern','Baden Wuerttemberg','Rheinland-Pfalz','Saarland']);\nLaender = np.array([1 ,2, 3, 4,\n                    5, 6, 7, 8,\n                    9, 10, 11, 12,\n                    13, 14, 15, 16]);\nplt.plot(Laender, SPD02DE, label = 'SPD',color='red') \nplt.plot(Laender, UN02DE, label = 'Union',color='black') \nplt.plot(Laender, BG02DE, label = 'SPDE',color='green') \nplt.plot(Laender, FDP02DE, label = 'FDP',color='#FFFF00') \nplt.plot(Laender, PDS02DE, label = 'PDS',color='#A2142F') \nplt.xticks(Laender,Bundeslaender,rotation=90)\nplt.ylabel(\"% of Total Votes\") \nplt.xlabel(\"Bundeslaender\") \nplt.title(\"2002 German Election Results\") \nplt.legend() \nplt.legend(loc='right')\nplt.show() \n\n\n\n\n\n\n\n\n\nMaybe I will try a hexplot next for union 2002. It is a mess and does nothing to help convey information for people to discover trends or be able to identify strongholds of the party.\n\n\nCode\nplt.style.use('_mpl-gallery-nogrid')\n\nfig, ax = plt.subplots()\n\nax.hexbin(Laender, UN02DE, gridsize=20)\n\nax.set(xlim=(0,20), ylim=(20,60))\n\nplt.show()\n\n\n\n\n\n\n\n\n\nThe next plot will be a box plot that shows the whole datasets for each party across all different geogrpahic boundaries. Except, this will not show geographic boundaries, it’ll show minimum and maximum vote percentages with an unknown confidence interval. Have fun determining which states are where within this box plot.\n\n\nCode\nlabels=['SPD','UN','BG','FDP','PDS']\ncolors=['red','black','green','#FFFF00','#A2142F']\n\nELplot=plt.boxplot([SPD02DE,UN02DE,BG02DE,FDP02DE,PDS02DE],patch_artist=\"true\",tick_labels=labels)\nplt.xticks=([1,2,3,4,5], ['SPD02DE','UN02DE','BG02DE','FDP02DE','PDS02DE'])\nfor patch, color in zip(ELplot['boxes'], colors):\n    patch.set_facecolor(color)\nplt.show()\n\n\n\n\n\n\n\n\n\nAlso, there is a favorite one of my experiments in data visuzliation I will add back in here\nThe following plots are attempts to recreate my matlab surface plots. These plots are inevitable.\n\n\nCode\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n# Plot the surface.\nFDP02DE2=FDP02DE.reshape(4,4)\ny=np.array([4,3,2,1]);\nx=np.array([1,2,3,4]);\n#surf(x,y,SPD02DE,'LineStyle',\":\")\nplt.ylabel('South-North')\nplt.xlabel('East-West')\n#plt.zlabel('Votes in %')\nplt.title('Surface Map of FDP Votes in DE 2002')\nsurf = ax.plot_surface(x, y, FDP02DE2, cmap=cm.coolwarm,linewidth=0, antialiased=False)\nax.view_init(-170, 45)\n#ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n# Plot the surface.\nPDS02DE2=PDS02DE.reshape(4,4)\ny=np.array([4,3,2,1]);\nx=np.array([1,2,3,4]);\n#surf(x,y,SPD02DE,'LineStyle',\":\")\nplt.ylabel('South-North')\nplt.xlabel('East-West')\n#plt.zlabel('Votes in %')\nplt.title('Surface Map of PDS Votes in DE 2002')\nsurf = ax.plot_surface(x, y, PDS02DE2, cmap=cm.coolwarm,linewidth=0, antialiased=False)\nax.view_init(-150, 45)\n#ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)\n\n\n\n\n\n\n\n\n\n\n\nCode\nfig, ax = plt.subplots(subplot_kw={\"projection\": \"3d\"})\n# Plot the surface.\nUN02DE2=UN02DE.reshape(4,4)\ny=np.array([4,3,2,1]);\nx=np.array([1,2,3,4]);\n#surf(x,y,SPD02DE,'LineStyle',\":\")\nplt.ylabel('South-North')\nplt.xlabel('East-West')\n#plt.zlabel('Votes in %')\nplt.title('Surface Map of PDS Votes in DE 2002')\nsurf = ax.plot_surface(x, y, UN02DE2, cmap=cm.coolwarm,linewidth=0, antialiased=False)\nax.view_init(-150, 45)\n#ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)"
  },
  {
    "objectID": "posts/Assignment5/Assignment5.html",
    "href": "posts/Assignment5/Assignment5.html",
    "title": "Some Ice Sport Doohickey",
    "section": "",
    "text": "import plotly.express as px import matplotlib.pyplot as plt import pandas as pd import statistics from matplotlib import cm import csv import tidypandas as tp DFGV=pd.read_csv(“Goalies.csv”, usecols=[‘Player’,‘GP’,‘TOI’,‘Shots Against’,‘Saves’,‘SV%’,‘HD Shots Against’,‘HD Saves’,‘HDSV%’]) #print(DFGV) DFSIT = pd.read_csv(“SkaterIndividualstats.csv”) #print(DFSIT) DFSOIS=pd.read_csv(“SkaterOnIcestats.csv”) #print(DFG) DFRG=pd.read_csv(“RookieGoalies.csv”) #print(DFRG) DFRSIT=pd.read_csv(“RookieSkaterOnIce.csv”) #print(DFRSIT) DFRSOIS=pd.read_csv(“RookieSkaterIndividual.csv”) #print(DFRSOIS)\nLet’s start with the Vezina trophy for the best goalie.\nDFGV=pd.read_csv(“Goalies.csv”, usecols=[‘Player’,‘GP’,‘TOI’,‘Shots Against’,‘Saves’,‘SV%’,‘HD Shots Against’,‘HD Saves’,‘HDSV%’])\nFirst I will filter out goalies who have fewer than 1000 saves\nfiltered_DFGV = DFGV[DFGV[‘Saves’] &gt;1000] display(filtered_DFGV)\nNext I’ll sort by the High Danger Save Percentages\nHDOrder=filtered_DFGV.sort_values(by=[‘HDSV%’], ascending=[0]) display(HDOrder)\nOne last order that I’m going to perform is to order goalies by save percentage before doing further filtering\nSVOrder=filtered_DFGV.sort_values(by=[‘SV%’], ascending=[0]) display(SVOrder)\nNow I’m going to run another filter on the data. This time I will set a filter that clears out anyone who has a High Danger Save Percentage lower than 80%.\nHDSVFilter=filtered_DFGV[filtered_DFGV[‘HDSV%’]&gt;0.8] display(HDSVFilter)\nNext is a second filter to filter out those who have a saver percentage beneath 90%.\nSVFilter=HDSVFilter[HDSVFilter[‘SV%’]&gt;0.9] display(SVFilter)\nThe next two reorderings will be first by HDSV percentage and then by SV percentage\nHDSVF=SVFilter.sort_values(by=[‘HDSV%’], ascending=[0]) display(HDSVF)\nSVFF=SVFilter.sort_values(by=[‘SV%’], ascending=[0]) display(SVFF)\nSAL=SVFilter.sort_values(by=[‘Shots Against’], ascending=[0])\nFirstly, I will plot players and their total number of shots against.\nplt.scatter(SAL[‘Player’],SAL[‘Shots Against’]) plt.xticks(SAL[‘Player’],rotation=90) plt.ylabel(‘Shots Against’) plt.title(‘Players and The Shots Against Them’) plt.show\nNext I will plot players and their save percentages and high danger save percentages.\nHDSVLL=SVFF.loc[:,‘HDSV%’] SVFFL=SVFF.loc[:,‘SV%’] GP=SVFF.loc[:,‘Player’] P1=plt.scatter(GP,HDSVLL) P2=plt.scatter(GP,SVFFL) plt.xticks(GP,rotation=90) plt.legend([P1,P2],[‘HDSV%’,‘SV%’]) plt.title(‘Players and Their Save and High Danger Save Percentages’) plt.show()\n\nFrom these plots and the tables generated in filtering and ordering the data I will create my ticket for the Vezina Trophy.\n\n\nMy ticket is as follows:\n\n\n1) Connor Hellebuyck\n\n\n2) Andrei Vasilevskiy\n\n\n3) Igor Shesterkin\n\n\n4) Mackenzie Blackwood\n\n\n5) Filip Gustavsson\nThe next trophy is the James Norris Memorial trophy for the best overall defenseman for the position.\nThe first thing I plan to do is run a filter on the data. For defesnsive players and other pertinent information like GP, TOI, CF, CA, CF% and PDO as metrics for their performance.\nDFRSOIS=pd.read_csv(“SkaterOnIcestats.csv”,usecols=[‘Player’,‘Position’,‘GP’,‘TOI’,‘CF’,‘CA’,‘CF%’,‘PDO’]) DFilter=DFRSOIS.sort_values(by=[‘Position’]) D=DFilter[DFilter[‘Position’]==‘D’] display(D)\nNext I will run a series of filters to filter for time on the ice and games played.\nDPFilter=D[D[‘GP’]&gt;60] TOIDFilter=DPFilter[DPFilter[‘TOI’]&gt;1300] display(TOIDFilter)\nI will reorder based on the total time on the ice that players are getting.\nTOIDOrder=TOIDFilter.sort_values(by=[‘TOI’],ascending=[0]) display(TOIDOrder)\nFrom here I can see that CF and CA values don’t directly correlate with time on the ice. From here I will reorder based on the CF% as a value greater than 55% is considered to be the best of the best.\nCFOrder=TOIDOrder.sort_values(by=[‘CF%’],ascending=[0]) display(CFOrder)\nCF=CFOrder.loc[:,‘CF’] TOID=CFOrder.loc[:,‘TOI’] DP=CFOrder.loc[:,‘Player’] Games=CFOrder.loc[:‘GP’] plt.scatter(TOIDOrder[‘Player’],TOIDOrder[‘TOI’]) plt.xticks(TOIDOrder[‘Player’],rotation=90) plt.ylabel(‘TIO(seconds)’) plt.title(‘Players and Their Time on the Ice’) plt.show\nOne final reordering will be based on PDO values as a value greater than one means that players are playing better than expected.\nPDOrder=TOIDOrder.sort_values(by=[‘PDO’],ascending=[0]) PDOD=PDOrder.loc[:,‘PDO’] display(PDOrder)\nThe following plot will plot players PDO values and their CF values which are their CF percentages divided by 100% to get them to a discrete decimal value scale. I also took the players’ time on the ice and divided it by 1000 seconds to get a discrete value for how many seconds they spend on the ice with the basis being 1000 seconds.\nPD1=plt.scatter(DP,PDOD) PD2=plt.scatter(DP,PDOrder[‘CF%’]/100) PD3=plt.scatter(DP,PDOrder[‘TOI’]/1000) plt.xticks(PDOrder[‘Player’],rotation=90) plt.legend([PD1,PD2,PD3],[‘PDO’,‘CF Value’,‘TOI (x1000)’]) plt.ylabel(‘PDO and discrete CF and TOI values’) plt.title(‘Players and Their Important Stats’) plt.show()\n\n\nBased on the above visualization my ticket for the James Norris Memorial Trophy is as follows:\n\n\n1) Lane Hutson\n\n\n2) Erik Karlsson\n\n\n3) John Carlson\n\n\n4) Alex Vlasic\n\n\n5) Brent Burns\nThe next trophy is going to be the Calder Memorial Trophy which goes to the best rookie in the league. I’m going to divide the data for rookies between goalies and non-goalies.\nFirst comes the rookie goalies. The data will be reordered to show who has had the most shots taken against them. Then the first filter will be applied. This will be based on games played.\nDFRG=pd.read_csv(“RookieGoalies.csv”,usecols=[‘Player’,‘GP’,‘TOI’,‘Shots Against’,‘Saves’,‘SV%’,‘HD Shots Against’,‘HD Saves’,‘HDSV%’]) DFRGFilter=DFRG[DFRG[‘GP’]&gt;25] DFRGSAO=DFRG.sort_values(by=[‘Shots Against’],ascending=[0]) display(DFRGSAO,DFRGFilter)\nRGSV=DFRGFilter.loc[:,‘SV%’] RGHDSV=DFRGFilter.loc[:,‘HDSV%’] RGP=DFRGFilter.loc[:,‘Player’] PRG1=plt.scatter(RGP,RGSV) PRG2=plt.scatter(RGP,RGHDSV) plt.legend([PRG1,PRG2],[‘SV%’,‘HDSV%’]) plt.xticks(RGP,rotation=90) plt.ylabel(‘SV and HDSV Percentages’) plt.title(‘Rookie Goalies and The Save They Make’) plt.show()\nRGSAT=DFRGFilter.sort_values(by=[‘Shots Against’],ascending=[0]) display(RGSAT)\nplt.scatter(RGP,RGSAT[‘Shots Against’]) plt.xticks(RGP,rotation=90) plt.ylabel(‘Shots Against’) plt.title(‘Rookie Goalies and the shots taken against them’) plt.show\n\n\nBefore moving on to other rookies I want to list my top five rookie goalies who I will consider for the Calder Memorial Trophy in conjunction with all other rookies.\n\n\nThe list is as follows:\n\n\n1) Dustin Wolf\n\n\n2) Logan Thompson\n\n\n3) Lukas Dostal\n\n\n4) Pyotr Kochetkov\n\n\n5) Joseph Woll\nFor the rest of the rookies I will initially pull all the data and filter them out by having a minimum CF value of 1100 and a minimum time on the ice of 1100 seconds. I’ll then reorder the rookie skater on ice data by PDO and CF% values in descending order. Afterward I will scale the CF% by dividing them by 100 to get them on the same scale as the PDO values and plot them against each other.\nDFRSIT=pd.read_csv(“RookieSkaterOnIce.csv”) DFRSOIS=pd.read_csv(“RookieSkaterIndividual.csv”) DFRSITFilter=DFRSIT[DFRSIT[‘CF’]&gt;1100] DFRSOISFilter=DFRSOIS[DFRSOIS[‘TOI’]&gt;1050] PDOROrder=DFRSITFilter.sort_values(by=[‘PDO’],ascending=[0]) RCFOrder=PDOROrder.sort_values(by=[‘CF%’],ascending=[0]) PDORV=PDOROrder.loc[:,‘PDO’] RCFV=RCFOrder.loc[:,‘CF%’] RGOL=DFRSOISFilter.loc[:,‘Goals’] RTAS=DFRSOISFilter.loc[:,‘Total Assists’] RTAW=DFRSOISFilter.loc[:,‘Takeaways’] RGAW=DFRSOISFilter.loc[:,‘Giveaways’] RSB=DFRSOISFilter.loc[:,‘Shots Blocked’] RTOI=DFRSOISFilter.loc[:,‘TOI’] RPRS=PDOROrder.loc[:,‘Player’] EXR=RGOL+RTAS+RTAW+RSB-RGAW EXRRPRS=DFRSOISFilter.loc[:,‘Player’] ORP=pd.DataFrame(DFRSOISFilter[‘Player’]) OP=pd.DataFrame(EXR) pd.concat([EXR,ORP],ignore_index=[1]) ORP[‘EXR’]=EXR ORP[‘RTOI’]=RTOI NORP=ORP.sort_values(by=[‘EXR’],ascending=[0]) display(NORP) RPS1=plt.scatter(RPRS,PDORV) RPS2=plt.scatter(RPRS,RCFV/100) plt.xticks(RPRS,rotation=90) plt.legend([RPS1,RPS2],[‘PDO’,‘CF%’]) plt.show()\nI also worked to get goals,total assists, giveaways, takeaways, and shots blocked. I’ll plot these against each other.\nfig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5)) plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4) for ax in fig.axes: plt.sca(ax) plt.xticks(rotation=90) ax1.scatter(EXRRPRS,RGOL,color=‘purple’) ax1.scatter(EXRRPRS,RTAS) ax1.legend([‘Goals’,‘Total Assists’]) ax1.title.set_text(‘Rookie Goals and Assists’)\nax2.scatter(EXRRPRS,RTAW,color=‘red’) ax2.scatter(EXRRPRS,RGAW,color=‘black’) ax2.scatter(EXRRPRS,RSB,color=‘green’) ax2.title.set_text(‘Rookie Takeaways, Giveaways, and Shots Blocked’) ax2.legend([‘Takeaways’,‘Giveaways’,‘Shots Blocked’]) plt.show()\nBased on these scatter plots, tables, and my goalie picks I’m going to assemble my list for the Calder Memorial Trophy.\n\n\nMy List for the Calder Memorial Trophy is as Follows:\n\n\n1) Kirill Marchenko\n\n\n2) Wyatt Johnston\n\n\n3) Dustin Wolf\n\n\n4) Marco Rossi\n\n\n5) Logan Thompson\nNext comes the Frank J Selke Trophy for the best overall defenseman in the league. This will include lefts and rights as well.\nDFRSOIS=pd.read_csv(“SkaterOnIcestats.csv”,usecols=[‘Player’,‘Position’,‘GP’,‘TOI’,‘CF’,‘CA’,‘CF%’,‘PDO’]) DFilter=DFRSOIS.sort_values(by=[‘Position’]) DP1=DFilter[DFilter[‘Position’]==‘D’] DP2=DFilter[DFilter[‘Position’]==‘L’] DP3=DFilter[DFilter[‘Position’]==‘R’] DPFilter=DP1[DP1[‘GP’]&gt;60] DP2Filter=DP2[DP2[‘GP’]&gt;60] DP3Filter=DP3[DP3[‘GP’]&gt;60] TOIDFilter=DPFilter[DPFilter[‘TOI’]&gt;1300] TOID2Filter=DP2Filter[DP2Filter[‘TOI’]&gt;900] TOID3Filter=DP3Filter[DP3Filter[‘TOI’]&gt;550] DCFOrder=TOIDFilter.sort_values(by=[‘CF%’],ascending=[0]) LCFOrder=TOID2Filter.sort_values(by=[‘CF%’],ascending=[0]) RCFOrder=TOID3Filter.sort_values(by=[‘CF%’],ascending=[0]) BD=DCFOrder.loc[:,‘Player’] BDCF=DCFOrder.loc[:,‘CF%’] BR=RCFOrder.loc[:,‘Player’] BRCF=RCFOrder.loc[:,‘CF%’] BL=LCFOrder.loc[:,‘Player’] BLCF=LCFOrder.loc[:,‘CF%’] BDD=pd.DataFrame(DCFOrder[‘Player’]) BDL=pd.DataFrame(LCFOrder[‘Player’]) BDR=pd.DataFrame(RCFOrder[‘Player’]) DCF=pd.DataFrame(DCFOrder[‘CF%’]) LCF=pd.DataFrame(LCFOrder[‘CF%’]) RCF=pd.DataFrame(RCFOrder[‘CF%’]) pd.concat([BDD,DCF],ignore_index=[1]) BDD[‘DCF’]=DCF NBDD=BDD.sort_values(by=[‘DCF’],ascending=0) pd.concat([BDL,LCF],ignore_index=[1]) BDL[‘LCF’]=LCF NBDL=BDL.sort_values(by=[‘LCF’],ascending=0) pd.concat([BDR,RCF],ignore_index=[1]) BDR[‘RCF’]=RCF NBDR=BDR.sort_values(by=[‘RCF’],ascending=0) DPDOrder=TOIDFilter.sort_values(by=[‘PDO’],ascending=[0]) LPDOrder=TOID2Filter.sort_values(by=[‘PDO’],ascending=[0]) RPDOrder=TOID3Filter.sort_values(by=[‘PDO’],ascending=[0]) DDD=DPDOrder.loc[:,‘Player’] DDP=DPDOrder.loc[:,‘PDO’] RRR=RPDOrder.loc[:,‘Player’] RRP=RPDOrder.loc[:,‘PDO’] LLL=LPDOrder.loc[:,‘Player’] LLP=LPDOrder.loc[:,‘PDO’] DPDO=pd.DataFrame(DPDOrder[‘PDO’]) RPDO=pd.DataFrame(RPDOrder[‘PDO’]) LPDO=pd.DataFrame(LPDOrder[‘PDO’]) DPDOP=pd.DataFrame(DPDOrder[‘Player’]) RPDOP=pd.DataFrame(RPDOrder[‘Player’]) LPDOP=pd.DataFrame(LPDOrder[‘Player’]) pd.concat([DPDOP,DPDO],ignore_index=[1]) DPDOP[‘PDO’]=DPDO NDPDOP=DPDOP.sort_values(by=[‘PDO’],ascending=0) pd.concat([RPDOP,RPDO],ignore_index=[1]) RPDOP[‘PDO’]=RPDO NRPDOP=RPDOP.sort_values(by=[‘PDO’],ascending=0) pd.concat([LPDOP],ignore_index=[1]) LPDOP[‘PDO’]=LPDO NLPDOP=LPDOP.sort_values(by=[‘PDO’],ascending=0) DCFTOI=pd.DataFrame(DCFOrder[‘TOI’]) RCFTOI=pd.DataFrame(RCFOrder[‘TOI’]) LCFTOI=pd.DataFrame(LCFOrder[‘TOI’]) pd.concat([NBDD,DCFTOI],ignore_index=[1]) NBDD[‘DCFTOI’]=DCFTOI pd.concat([NBDD,DCFTOI],ignore_index=[1]) NBDR[‘RCFTOI’]=RCFTOI pd.concat([NBDD,DCFTOI],ignore_index=[1]) NBDL[‘LCFTOI’]=LCFTOI DPDOTOI=pd.DataFrame(DPDOrder[‘TOI’]) RPDOTOI=pd.DataFrame(RPDOrder[‘TOI’]) LPDOTOI=pd.DataFrame(LPDOrder[‘TOI’]) pd.concat([DPDO,DPDOTOI],ignore_index=[1]) DPDO[‘DPDOTOI’]=DPDOTOI RPDO[‘RPDOTOI’]=RPDOTOI LPDO[‘LPDOTOI’]=LPDOTOI OKD=BDCF OKR=BRCF OKL=BLCF\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 5)) plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4) for ax in fig.axes: plt.sca(ax) plt.xticks(rotation=90) ax1.scatter(BD,BDCF,color=‘purple’) ax1.scatter(DDD,OKD,color=‘gold’) ax1.legend([‘CF%’,‘PDO’]) ax1.title.set_text(‘Defense CF% and PDO’)\nax2.scatter(BL,BLCF,color=‘gold’) ax2.scatter(LLL,OKL,color=‘green’) ax2.title.set_text(‘Left Defense CF% and PDO’) ax2.legend([‘CF%’,‘PDO’])\nax3.scatter(BR,BRCF,color=‘gold’) ax3.scatter(RRR,OKR,color=‘grey’) ax3.title.set_text(‘Right Defense CF% and PDO’) ax3.legend([‘CF%’,‘PDO’])\nplt.show()\nI’m going to exclude time played from this analysis and nomination set because the scale of time on the ice between the different defensive player clusters is too large.\n\n\nMy list for the Frank J Selke Trophy is as follows:\n\n\n1) Cale Makar\n\n\n2) Jackson Blake\n\n\n3) Pierre-Luc Dubois\n\n\n4) John Carlson\n\n\n5) William Nylander\nNext will be the Hart Memorial Trophy for the player dubbed most valuable to his team. For the sake of time this will solely be based off of previously generated visualizaitons.\nThe first visulization will be for the goalies. Something important to note is that the values in the visualizations will be different for the goalies since they lack a CF% and PDO value compared to offensive and defensive players.\nHDSVLL=SVFF.loc[:,‘HDSV%’] SVFFL=SVFF.loc[:,‘SV%’] GP=SVFF.loc[:,‘Player’] P1=plt.scatter(GP,HDSVLL) P2=plt.scatter(GP,SVFFL) plt.xticks(GP,rotation=90) plt.legend([P1,P2],[‘HDSV%’,‘SV%’]) plt.title(‘Players and Their Save and High Danger Save Percentages’) plt.show()\nNext will be the defensemen.\nPD1=plt.scatter(DP,PDOD) PD2=plt.scatter(DP,PDOrder[‘CF%’]/100) PD3=plt.scatter(DP,PDOrder[‘TOI’]/1000) plt.xticks(PDOrder[‘Player’],rotation=90) plt.legend([PD1,PD2,PD3],[‘PDO’,‘CF Value’,‘TOI (x1000)’]) plt.ylabel(‘PDO and discrete CF and TOI values’) plt.title(‘Players and Their Important Stats’) plt.show()\nNow come all the defensive players including the left and right defenders.\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 5)) plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4) for ax in fig.axes: plt.sca(ax) plt.xticks(rotation=90) ax1.scatter(BD,BDCF,color=‘purple’) ax1.scatter(DDD,OKD,color=‘gold’) ax1.legend([‘CF%’,‘PDO’]) ax1.title.set_text(‘Defense CF% and PDO’)\nax2.scatter(BL,BLCF,color=‘gold’) ax2.scatter(LLL,OKL,color=‘green’) ax2.title.set_text(‘Left Defense CF% and PDO’) ax2.legend([‘CF%’,‘PDO’])\nax3.scatter(BR,BRCF,color=‘gold’) ax3.scatter(RRR,OKR,color=‘grey’) ax3.title.set_text(‘Right Defense CF% and PDO’) ax3.legend([‘CF%’,‘PDO’])\nplt.show()\nLastly, we’ll bring the rookies into the ring since they too deserve to be considered for being the most valuable player potentially.\nRGSV=DFRGFilter.loc[:,‘SV%’] RGHDSV=DFRGFilter.loc[:,‘HDSV%’] RGP=DFRGFilter.loc[:,‘Player’] PRG1=plt.scatter(RGP,RGSV) PRG2=plt.scatter(RGP,RGHDSV) plt.legend([PRG1,PRG2],[‘SV%’,‘HDSV%’]) plt.xticks(RGP,rotation=90) plt.ylabel(‘SV and HDSV Percentages’) plt.title(‘Rookie Goalies and The Save They Make’) plt.show()\nfig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5)) plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4) for ax in fig.axes: plt.sca(ax) plt.xticks(rotation=90) ax1.scatter(EXRRPRS,RGOL,color=‘purple’) ax1.scatter(EXRRPRS,RTAS) ax1.legend([‘Goals’,‘Total Assists’]) ax1.title.set_text(‘Rookie Goals and Assists’)\nax2.scatter(EXRRPRS,RTAW,color=‘red’) ax2.scatter(EXRRPRS,RGAW,color=‘black’) ax2.scatter(EXRRPRS,RSB,color=‘green’) ax2.title.set_text(‘Rookie Takeaways, Giveaways, and Shots Blocked’) ax2.legend([‘Takeaways’,‘Giveaways’,‘Shots Blocked’]) plt.show()\nNow that all of the previously generated visualiztions are here, it’s time to get a new one added to the mix. Essentially it’ll be just like the Rookie Goals and Assists set of visualizations but for the more seasoned skaters. TOI will be divided by 100 seconds to properly scale it and discreitze it so it can be more easily visualized.\nDFSIT = pd.read_csv(“SkaterOnIcestats.csv”) DFSITFilter=DFSIT[DFSIT[‘CF’]&gt;1550] PDOSOrder=DFSITFilter.sort_values(by=[‘PDO’],ascending=[0]) SCFOrder=PDOSOrder.sort_values(by=[‘CF%’],ascending=[0]) PDOSV=PDOSOrder.loc[:,‘PDO’] SCFV=SCFOrder.loc[:,‘CF%’]/100 SGOL=PDOSOrder.loc[:,‘GF%’] STAS=DFSITFilter.loc[:,‘FA’] STAHDG=DFSITFilter.loc[:,‘HDGF%’] SGAW=DFSITFilter.loc[:,‘GA’] SSB=DFSITFilter.loc[:,‘On-Ice SV%’] STOI=DFSITFilter.loc[:,‘TOI’]/100 SPRS=PDOSOrder.loc[:,‘Player’] EXSRPRS=DFSITFilter.loc[:,‘Player’] OSP=pd.DataFrame(DFSITFilter[‘Player’])\nfig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5)) plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4) for ax in fig.axes: plt.sca(ax) plt.xticks(rotation=90) ax1.scatter(SPRS,PDOSV,color=‘purple’) ax1.scatter(SPRS,SCFV) ax1.legend([‘Goals’,‘high Danger Goals’]) ax1.title.set_text(‘PDO and CF’)\nax2.scatter(EXSRPRS,SSB,color=‘red’) ax2.scatter(EXSRPRS,STAHDG,color=‘black’) ax2.scatter(EXSRPRS,STOI,color=‘green’) ax2.title.set_text(‘On-Ice SV%, HDGF%, and TOI’) ax2.legend([‘On-Ice SV%’,‘HDGF%’,‘TOI (x100)’]) plt.show()\n\n\nNow it comes time to make my picks for the Hart Memorial Trophy. The list is as follows:\n\n\n1) Connor Hellbuyck\n\n\n2) Zach Weresnki\n\n\n3) Kirill Marchenko\n\n\n4) Dustin Wolf\n\n\n5) John Carlson\nLastly comes the Lady Byng trophy given to the athlete who displays the best sportsmanship and skills. Information related to skill is going to be pulled from the Hart Memorial Trophy visualizations above, but for sportsmanship the primary metrics being looked at will be penalties incurred by skaters.\nRPEN=pd.read_csv(“RookieSkaterIndividual.csv”,usecols=[‘Player’,‘TOI’,‘PIM’,‘Total Penalties’,‘Minor’,‘Major’,‘Misconduct’,‘Penalties Drawn’]) SPEN=pd.read_csv(“SkaterIndividualstats.csv”,usecols=[‘Player’,‘TOI’,‘PIM’,‘Total Penalties’,‘Minor’,‘Major’,‘Misconduct’,‘Penalties Drawn’]) SPEN.sort_values(by=[‘Major’],ascending=[1]) SPENFilter=SPEN[SPEN[‘TOI’]&gt;1400] display(SPENFilter) SPPS=SPENFilter.loc[:,‘Player’] SPIM=SPENFilter.loc[:,‘PIM’] STP=SPENFilter.loc[:,‘Total Penalties’] SMI=SPENFilter.loc[:,‘Minor’] SMJ=SPENFilter.loc[:,‘Major’] SMC=SPENFilter.loc[:,‘Misconduct’] SPD=SPENFilter.loc[:,‘Penalties Drawn’] SPENT=SPIM+STP+SMI+SMJ+SMC+SPD SPENT1=pd.DataFrame(SPENT) SPPS1=pd.DataFrame(SPPS) AG=pd.concat([SPENT,SPPS],ignore_index=[1]) SPPS1[‘SPENT1’]=SPENT1 SPPS1.sort_values(by=[‘SPENT1’],ascending=[1])\nThe players with the best sportmanship will have the lowest SPENT1 values above. The problem is that there are tons of them with a score of 0. I then sorted by TOI with a minimum TOI of 1500 required. From here I looked at more seasoned players who were in the above nominations. These include Cale Makar, Erik Karlsson, John Carlson, and Zach Werenski. Next will come the rookies.\nRPENFilter=RPEN[RPEN[‘TOI’]&gt;1000] display(RPENFilter) RPPS=RPENFilter.loc[:,‘Player’] RPIM=RPENFilter.loc[:,‘PIM’] RTP=RPENFilter.loc[:,‘Total Penalties’] RMI=RPENFilter.loc[:,‘Minor’] RMJ=RPENFilter.loc[:,‘Major’] RMC=RPENFilter.loc[:,‘Misconduct’] RPD=RPENFilter.loc[:,‘Penalties Drawn’] RPENT=RPIM+RTP+RMI+RMJ+RMC+RPD RPENT1=pd.DataFrame(RPENT) RPPS1=pd.DataFrame(RPPS) RG=pd.concat([RPENT,RPPS],ignore_index=[1]) RPPS1[‘RPENT1’]=RPENT1 RPPS1.sort_values(by=[‘RPENT1’],ascending=[1])\nCale=42 Erik=43 John=43 Zach=68 Alex=25 Wyatt=34 Kirill=41\nSome names seen previously include Alex Vlasic, Wyatt Johnston, and Kirill Marchenko. Next comes time to compare these players specifically. Interestingly enough the rookies have lower incursion scores which is the sum of major and minor penalties, penalties drawn, PIM, total penalties, and misconduct.\n\n\nMy list for the Lady Byng Trophy is as follows:\n\n\n1) Cale Makar\n\n\n2) Kirill Marchenko\n\n\n3) Alex Vlasic\n\n\n4) Erik Karlsson\n\n\n5) John Carlson"
  },
  {
    "objectID": "Assignment5.html",
    "href": "Assignment5.html",
    "title": "From these plots and the tables generated in filtering and ordering the data I will create my ticket for the Vezina Trophy.",
    "section": "",
    "text": "import plotly.express as px\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport statistics\nfrom matplotlib import cm\nimport csv\nimport tidypandas as tp\nDFGV=pd.read_csv(\"Goalies.csv\", usecols=['Player','GP','TOI','Shots Against','Saves','SV%','HD Shots Against','HD Saves','HDSV%'])\n#print(DFGV)\nDFSIT = pd.read_csv(\"SkaterIndividualstats.csv\")\n#print(DFSIT)\nDFSOIS=pd.read_csv(\"SkaterOnIcestats.csv\")\n#print(DFG)\nDFRG=pd.read_csv(\"RookieGoalies.csv\")\n#print(DFRG)\nDFRSIT=pd.read_csv(\"RookieSkaterOnIce.csv\")\n#print(DFRSIT)\nDFRSOIS=pd.read_csv(\"RookieSkaterIndividual.csv\")\n#print(DFRSOIS)\n\nLet’s start with the Vezina trophy for the best goalie.\n\nDFGV=pd.read_csv(\"Goalies.csv\", usecols=['Player','GP','TOI','Shots Against','Saves','SV%','HD Shots Against','HD Saves','HDSV%'])\n\nFirst I will filter out goalies who have fewer than 1000 saves\n\nfiltered_DFGV = DFGV[DFGV['Saves'] &gt;1000]\ndisplay(filtered_DFGV)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n20\nJake Oettinger\n44\n2584.833333\n1175\n1070\n0.911\n288\n228\n0.792\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n43\nJordan Binnington\n43\n2460.250000\n1136\n1021\n0.899\n275\n221\n0.804\n\n\n44\nSam Montembeault\n46\n2567.866667\n1232\n1108\n0.899\n357\n293\n0.821\n\n\n47\nJuuse Saros\n45\n2598.666667\n1252\n1124\n0.898\n337\n277\n0.822\n\n\n49\nElvis Merzlikins\n40\n2408.183333\n1154\n1035\n0.897\n319\n261\n0.818\n\n\n50\nJeremy Swayman\n44\n2600.733333\n1247\n1119\n0.897\n303\n237\n0.782\n\n\n57\nUkko-Pekka Luukkonen\n43\n2448.783333\n1163\n1040\n0.894\n302\n240\n0.795\n\n\n\n\n\n\n\nNext I’ll sort by the High Danger Save Percentages\n\nHDOrder=filtered_DFGV.sort_values(by=['HDSV%'], ascending=[0])\ndisplay(HDOrder)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n47\nJuuse Saros\n45\n2598.666667\n1252\n1124\n0.898\n337\n277\n0.822\n\n\n44\nSam Montembeault\n46\n2567.866667\n1232\n1108\n0.899\n357\n293\n0.821\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n49\nElvis Merzlikins\n40\n2408.183333\n1154\n1035\n0.897\n319\n261\n0.818\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n43\nJordan Binnington\n43\n2460.250000\n1136\n1021\n0.899\n275\n221\n0.804\n\n\n57\nUkko-Pekka Luukkonen\n43\n2448.783333\n1163\n1040\n0.894\n302\n240\n0.795\n\n\n20\nJake Oettinger\n44\n2584.833333\n1175\n1070\n0.911\n288\n228\n0.792\n\n\n50\nJeremy Swayman\n44\n2600.733333\n1247\n1119\n0.897\n303\n237\n0.782\n\n\n\n\n\n\n\nOne last order that I’m going to perform is to order goalies by save percentage before doing further filtering\n\nSVOrder=filtered_DFGV.sort_values(by=['SV%'], ascending=[0])\ndisplay(SVOrder)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n20\nJake Oettinger\n44\n2584.833333\n1175\n1070\n0.911\n288\n228\n0.792\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n43\nJordan Binnington\n43\n2460.250000\n1136\n1021\n0.899\n275\n221\n0.804\n\n\n44\nSam Montembeault\n46\n2567.866667\n1232\n1108\n0.899\n357\n293\n0.821\n\n\n47\nJuuse Saros\n45\n2598.666667\n1252\n1124\n0.898\n337\n277\n0.822\n\n\n49\nElvis Merzlikins\n40\n2408.183333\n1154\n1035\n0.897\n319\n261\n0.818\n\n\n50\nJeremy Swayman\n44\n2600.733333\n1247\n1119\n0.897\n303\n237\n0.782\n\n\n57\nUkko-Pekka Luukkonen\n43\n2448.783333\n1163\n1040\n0.894\n302\n240\n0.795\n\n\n\n\n\n\n\nNow I’m going to run another filter on the data. This time I will set a filter that clears out anyone who has a High Danger Save Percentage lower than 80%.\n\nHDSVFilter=filtered_DFGV[filtered_DFGV['HDSV%']&gt;0.8]\ndisplay(HDSVFilter)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n43\nJordan Binnington\n43\n2460.250000\n1136\n1021\n0.899\n275\n221\n0.804\n\n\n44\nSam Montembeault\n46\n2567.866667\n1232\n1108\n0.899\n357\n293\n0.821\n\n\n47\nJuuse Saros\n45\n2598.666667\n1252\n1124\n0.898\n337\n277\n0.822\n\n\n49\nElvis Merzlikins\n40\n2408.183333\n1154\n1035\n0.897\n319\n261\n0.818\n\n\n\n\n\n\n\nNext is a second filter to filter out those who have a saver percentage beneath 90%.\n\nSVFilter=HDSVFilter[HDSVFilter['SV%']&gt;0.9]\ndisplay(SVFilter)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n\n\n\n\n\nThe next two reorderings will be first by HDSV percentage and then by SV percentage\n\nHDSVF=SVFilter.sort_values(by=['HDSV%'], ascending=[0])\ndisplay(HDSVF)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n\n\n\n\n\n\nSVFF=SVFilter.sort_values(by=['SV%'], ascending=[0])\ndisplay(SVFF)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n4\nConnor Hellebuyck\n46\n2771.733333\n1262\n1170\n0.927\n293\n253\n0.863\n\n\n9\nAndrei Vasilevskiy\n48\n2837.050000\n1335\n1232\n0.923\n317\n271\n0.855\n\n\n11\nMackenzie Blackwood\n44\n2504.983333\n1229\n1125\n0.915\n309\n260\n0.841\n\n\n12\nFilip Gustavsson\n40\n2348.033333\n1190\n1088\n0.914\n274\n229\n0.836\n\n\n13\nJoey Daccord\n41\n2365.866667\n1167\n1066\n0.913\n285\n233\n0.818\n\n\n23\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n30\nIgor Shesterkin\n44\n2493.083333\n1263\n1144\n0.906\n358\n295\n0.824\n\n\n37\nIlya Sorokin\n45\n2575.083333\n1237\n1117\n0.903\n322\n264\n0.820\n\n\n\n\n\n\n\n\nSAL=SVFilter.sort_values(by=['Shots Against'], ascending=[0])\n\nFirstly, I will plot players and their total number of shots against.\n\nplt.scatter(SAL['Player'],SAL['Shots Against'])\nplt.xticks(SAL['Player'],rotation=90)\nplt.ylabel('Shots Against')\nplt.title('Players and The Shots Against Them')\nplt.show\n\n\n\n\n\n\n\n\nNext I will plot players and their save percentages and high danger save percentages.\n\nHDSVLL=SVFF.loc[:,'HDSV%']\nSVFFL=SVFF.loc[:,'SV%']\nGP=SVFF.loc[:,'Player']\nP1=plt.scatter(GP,HDSVLL)\nP2=plt.scatter(GP,SVFFL)\nplt.xticks(GP,rotation=90)\nplt.legend([P1,P2],['HDSV%','SV%'])\nplt.title('Players and Their Save and High Danger Save Percentages')\nplt.show()\n\n\n\n\n\n\n\n\n\nFrom these plots and the tables generated in filtering and ordering the data I will create my ticket for the Vezina Trophy.\n\n\nMy ticket is as follows:\n\n\n1) Connor Hellebuyck\n\n\n2) Andrei Vasilevskiy\n\n\n3) Igor Shesterkin\n\n\n4) Mackenzie Blackwood\n\n\n5) Filip Gustavsson\nThe next trophy is the James Norris Memorial trophy for the best overall defenseman for the position.\nThe first thing I plan to do is run a filter on the data. For defesnsive players and other pertinent information like GP, TOI, CF, CA, CF% and PDO as metrics for their performance.\n\nDFRSOIS=pd.read_csv(\"SkaterOnIcestats.csv\",usecols=['Player','Position','GP','TOI','CF','CA','CF%','PDO'])\nDFilter=DFRSOIS.sort_values(by=['Position'])\nD=DFilter[DFilter['Position']=='D']\ndisplay(D)\n\n\n\n\n\n\n\n\nPlayer\nPosition\nGP\nTOI\nCF\nCA\nCF%\nPDO\n\n\n\n\n820\nJamie Oleksiak\nD\n61\n1157.750000\n927\n1500\n38.20\n0.990\n\n\n543\nRasmus Andersson\nD\n60\n1447.283333\n1471\n1673\n46.79\n0.961\n\n\n560\nDamon Severson\nD\n57\n1122.416667\n1007\n1161\n46.45\n1.000\n\n\n559\nDavid Jiricek\nD\n12\n145.416667\n125\n144\n46.47\n1.017\n\n\n545\nDante Fabbro\nD\n47\n971.250000\n944\n1075\n46.76\n0.999\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n370\nRasmus Sandin\nD\n61\n1162.483333\n1114\n1076\n50.87\n1.028\n\n\n372\nNoah Hanifin\nD\n60\n1278.133333\n1309\n1265\n50.85\n0.974\n\n\n457\nNeal Pionk\nD\n61\n1355.500000\n1316\n1377\n48.87\n1.031\n\n\n1\nSamuel Bolduc\nD\n1\n5.933333\n7\n2\n77.78\n0.000\n\n\n459\nKeaton Middleton\nD\n28\n301.166667\n253\n265\n48.84\n1.004\n\n\n\n\n299 rows × 8 columns\n\n\n\nNext I will run a series of filters to filter for time on the ice and games played.\n\nDPFilter=D[D['GP']&gt;60]\nTOIDFilter=DPFilter[DPFilter['TOI']&gt;1300]\ndisplay(TOIDFilter)\n\n\n\n\n\n\n\n\nPlayer\nPosition\nGP\nTOI\nCF\nCA\nCF%\nPDO\n\n\n\n\n659\nDylan DeMelo\nD\n61\n1313.350000\n1112\n1411\n44.07\n1.033\n\n\n633\nColton Parayko\nD\n61\n1455.716667\n1222\n1527\n44.45\n0.994\n\n\n813\nCody Ceci\nD\n63\n1362.033333\n1081\n1723\n38.55\n0.999\n\n\n758\nAlex Vlasic\nD\n61\n1444.850000\n1093\n1564\n41.14\n1.008\n\n\n761\nMario Ferraro\nD\n62\n1302.216667\n1083\n1567\n40.87\n0.966\n\n\n611\nTravis Sanheim\nD\n61\n1496.050000\n1303\n1588\n45.07\n0.984\n\n\n285\nJaccob Slavin\nD\n61\n1323.950000\n1411\n1272\n52.59\n0.990\n\n\n270\nMorgan Rielly\nD\n61\n1315.700000\n1416\n1258\n52.95\n0.998\n\n\n167\nErik Karlsson\nD\n63\n1466.800000\n1745\n1407\n55.36\n0.979\n\n\n148\nBrent Burns\nD\n61\n1302.533333\n1533\n1214\n55.81\n0.973\n\n\n127\nCale Makar\nD\n61\n1574.800000\n1853\n1411\n56.77\n1.011\n\n\n229\nJohn Carlson\nD\n61\n1452.316667\n1612\n1384\n53.81\n1.020\n\n\n209\nLane Hutson\nD\n61\n1365.283333\n1487\n1249\n54.35\n0.992\n\n\n401\nGustav Forsling\nD\n62\n1418.650000\n1467\n1464\n50.05\n1.009\n\n\n457\nNeal Pionk\nD\n61\n1355.500000\n1316\n1377\n48.87\n1.031\n\n\n\n\n\n\n\nI will reorder based on the total time on the ice that players are getting.\n\nTOIDOrder=TOIDFilter.sort_values(by=['TOI'],ascending=[0])\ndisplay(TOIDOrder)\n\n\n\n\n\n\n\n\nPlayer\nPosition\nGP\nTOI\nCF\nCA\nCF%\nPDO\n\n\n\n\n127\nCale Makar\nD\n61\n1574.800000\n1853\n1411\n56.77\n1.011\n\n\n611\nTravis Sanheim\nD\n61\n1496.050000\n1303\n1588\n45.07\n0.984\n\n\n167\nErik Karlsson\nD\n63\n1466.800000\n1745\n1407\n55.36\n0.979\n\n\n633\nColton Parayko\nD\n61\n1455.716667\n1222\n1527\n44.45\n0.994\n\n\n229\nJohn Carlson\nD\n61\n1452.316667\n1612\n1384\n53.81\n1.020\n\n\n758\nAlex Vlasic\nD\n61\n1444.850000\n1093\n1564\n41.14\n1.008\n\n\n401\nGustav Forsling\nD\n62\n1418.650000\n1467\n1464\n50.05\n1.009\n\n\n209\nLane Hutson\nD\n61\n1365.283333\n1487\n1249\n54.35\n0.992\n\n\n813\nCody Ceci\nD\n63\n1362.033333\n1081\n1723\n38.55\n0.999\n\n\n457\nNeal Pionk\nD\n61\n1355.500000\n1316\n1377\n48.87\n1.031\n\n\n285\nJaccob Slavin\nD\n61\n1323.950000\n1411\n1272\n52.59\n0.990\n\n\n270\nMorgan Rielly\nD\n61\n1315.700000\n1416\n1258\n52.95\n0.998\n\n\n659\nDylan DeMelo\nD\n61\n1313.350000\n1112\n1411\n44.07\n1.033\n\n\n148\nBrent Burns\nD\n61\n1302.533333\n1533\n1214\n55.81\n0.973\n\n\n761\nMario Ferraro\nD\n62\n1302.216667\n1083\n1567\n40.87\n0.966\n\n\n\n\n\n\n\nFrom here I can see that CF and CA values don’t directly correlate with time on the ice. From here I will reorder based on the CF% as a value greater than 55% is considered to be the best of the best.\n\nCFOrder=TOIDOrder.sort_values(by=['CF%'],ascending=[0])\ndisplay(CFOrder)\n\n\n\n\n\n\n\n\nPlayer\nPosition\nGP\nTOI\nCF\nCA\nCF%\nPDO\n\n\n\n\n127\nCale Makar\nD\n61\n1574.800000\n1853\n1411\n56.77\n1.011\n\n\n148\nBrent Burns\nD\n61\n1302.533333\n1533\n1214\n55.81\n0.973\n\n\n167\nErik Karlsson\nD\n63\n1466.800000\n1745\n1407\n55.36\n0.979\n\n\n209\nLane Hutson\nD\n61\n1365.283333\n1487\n1249\n54.35\n0.992\n\n\n229\nJohn Carlson\nD\n61\n1452.316667\n1612\n1384\n53.81\n1.020\n\n\n270\nMorgan Rielly\nD\n61\n1315.700000\n1416\n1258\n52.95\n0.998\n\n\n285\nJaccob Slavin\nD\n61\n1323.950000\n1411\n1272\n52.59\n0.990\n\n\n401\nGustav Forsling\nD\n62\n1418.650000\n1467\n1464\n50.05\n1.009\n\n\n457\nNeal Pionk\nD\n61\n1355.500000\n1316\n1377\n48.87\n1.031\n\n\n611\nTravis Sanheim\nD\n61\n1496.050000\n1303\n1588\n45.07\n0.984\n\n\n633\nColton Parayko\nD\n61\n1455.716667\n1222\n1527\n44.45\n0.994\n\n\n659\nDylan DeMelo\nD\n61\n1313.350000\n1112\n1411\n44.07\n1.033\n\n\n758\nAlex Vlasic\nD\n61\n1444.850000\n1093\n1564\n41.14\n1.008\n\n\n761\nMario Ferraro\nD\n62\n1302.216667\n1083\n1567\n40.87\n0.966\n\n\n813\nCody Ceci\nD\n63\n1362.033333\n1081\n1723\n38.55\n0.999\n\n\n\n\n\n\n\n\nCF=CFOrder.loc[:,'CF']\nTOID=CFOrder.loc[:,'TOI']\nDP=CFOrder.loc[:,'Player']\nGames=CFOrder.loc[:'GP']\nplt.scatter(TOIDOrder['Player'],TOIDOrder['TOI'])\nplt.xticks(TOIDOrder['Player'],rotation=90)\nplt.ylabel('TIO(seconds)')\nplt.title('Players and Their Time on the Ice')\nplt.show\n\n\n\n\n\n\n\n\nOne final reordering will be based on PDO values as a value greater than one means that players are playing better than expected.\n\nPDOrder=TOIDOrder.sort_values(by=['PDO'],ascending=[0])\nPDOD=PDOrder.loc[:,'PDO']\ndisplay(PDOrder)\n\n\n\n\n\n\n\n\nPlayer\nPosition\nGP\nTOI\nCF\nCA\nCF%\nPDO\n\n\n\n\n659\nDylan DeMelo\nD\n61\n1313.350000\n1112\n1411\n44.07\n1.033\n\n\n457\nNeal Pionk\nD\n61\n1355.500000\n1316\n1377\n48.87\n1.031\n\n\n229\nJohn Carlson\nD\n61\n1452.316667\n1612\n1384\n53.81\n1.020\n\n\n127\nCale Makar\nD\n61\n1574.800000\n1853\n1411\n56.77\n1.011\n\n\n401\nGustav Forsling\nD\n62\n1418.650000\n1467\n1464\n50.05\n1.009\n\n\n758\nAlex Vlasic\nD\n61\n1444.850000\n1093\n1564\n41.14\n1.008\n\n\n813\nCody Ceci\nD\n63\n1362.033333\n1081\n1723\n38.55\n0.999\n\n\n270\nMorgan Rielly\nD\n61\n1315.700000\n1416\n1258\n52.95\n0.998\n\n\n633\nColton Parayko\nD\n61\n1455.716667\n1222\n1527\n44.45\n0.994\n\n\n209\nLane Hutson\nD\n61\n1365.283333\n1487\n1249\n54.35\n0.992\n\n\n285\nJaccob Slavin\nD\n61\n1323.950000\n1411\n1272\n52.59\n0.990\n\n\n611\nTravis Sanheim\nD\n61\n1496.050000\n1303\n1588\n45.07\n0.984\n\n\n167\nErik Karlsson\nD\n63\n1466.800000\n1745\n1407\n55.36\n0.979\n\n\n148\nBrent Burns\nD\n61\n1302.533333\n1533\n1214\n55.81\n0.973\n\n\n761\nMario Ferraro\nD\n62\n1302.216667\n1083\n1567\n40.87\n0.966\n\n\n\n\n\n\n\nThe following plot will plot players PDO values and their CF values which are their CF percentages divided by 100% to get them to a discrete decimal value scale. I also took the players’ time on the ice and divided it by 1000 seconds to get a discrete value for how many seconds they spend on the ice with the basis being 1000 seconds.\n\nPD1=plt.scatter(DP,PDOD)\nPD2=plt.scatter(DP,PDOrder['CF%']/100)\nPD3=plt.scatter(DP,PDOrder['TOI']/1000)\nplt.xticks(PDOrder['Player'],rotation=90)\nplt.legend([PD1,PD2,PD3],['PDO','CF Value','TOI (x1000)'])\nplt.ylabel('PDO and discrete CF and TOI values')\nplt.title('Players and Their Important Stats')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nBased on the above visualization my ticket for the James Norris Memorial Trophy is as follows:\n\n\n1) Lane Hutson\n\n\n2) Erik Karlsson\n\n\n3) John Carlson\n\n\n4) Alex Vlasic\n\n\n5) Brent Burns\nThe next trophy is going to be the Calder Memorial Trophy which goes to the best rookie in the league. I’m going to divide the data for rookies between goalies and non-goalies.\nFirst comes the rookie goalies. The data will be reordered to show who has had the most shots taken against them. Then the first filter will be applied. This will be based on games played.\n\nDFRG=pd.read_csv(\"RookieGoalies.csv\",usecols=['Player','GP','TOI','Shots Against','Saves','SV%','HD Shots Against','HD Saves','HDSV%'])\nDFRGFilter=DFRG[DFRG['GP']&gt;25]\nDFRGSAO=DFRG.sort_values(by=['Shots Against'],ascending=[0])\ndisplay(DFRGSAO,DFRGFilter)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n16\nUkko-Pekka Luukkonen\n43\n2448.783333\n1163\n1040\n0.894\n302\n240\n0.795\n\n\n7\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n13\nStuart Skinner\n40\n2321.033333\n1083\n973\n0.898\n263\n211\n0.802\n\n\n6\nDustin Wolf\n36\n2164.833333\n1073\n980\n0.913\n278\n235\n0.845\n\n\n5\nLogan Thompson\n35\n2096.033333\n985\n904\n0.918\n266\n222\n0.835\n\n\n11\nPyotr Kochetkov\n37\n2196.766667\n926\n835\n0.902\n297\n254\n0.855\n\n\n8\nJoseph Woll\n32\n1886.366667\n918\n833\n0.907\n235\n190\n0.809\n\n\n9\nArvid Soderblom\n29\n1668.533333\n895\n811\n0.906\n247\n199\n0.806\n\n\n17\nSamuel Ersson\n34\n1890.450000\n836\n747\n0.894\n196\n159\n0.811\n\n\n15\nDan Vladar\n24\n1447.983333\n677\n605\n0.894\n162\n122\n0.753\n\n\n12\nJoel Hofer\n23\n1248.266667\n603\n542\n0.899\n120\n92\n0.767\n\n\n18\nJustus Annunen\n24\n1234.300000\n588\n522\n0.888\n135\n114\n0.844\n\n\n19\nDaniil Tarasov\n15\n905.016667\n452\n398\n0.881\n130\n100\n0.769\n\n\n14\nYaroslav Askarov\n13\n716.800000\n357\n320\n0.896\n102\n84\n0.824\n\n\n3\nLeevi Merilainen\n12\n662.983333\n295\n273\n0.925\n62\n50\n0.806\n\n\n22\nDevon Levi\n9\n480.633333\n258\n225\n0.872\n63\n46\n0.730\n\n\n26\nCayden Primeau\n11\n523.700000\n250\n209\n0.836\n77\n60\n0.779\n\n\n23\nArturs Silovs\n9\n482.516667\n219\n188\n0.858\n59\n44\n0.746\n\n\n10\nJet Greaves\n5\n301.633333\n159\n144\n0.906\n47\n40\n0.851\n\n\n2\nMarcus Hogberg\n7\n332.016667\n151\n143\n0.947\n37\n32\n0.865\n\n\n4\nJaxson Stauber\n4\n242.416667\n120\n111\n0.925\n27\n24\n0.889\n\n\n1\nNico Daws\n5\n204.683333\n88\n85\n0.966\n24\n22\n0.917\n\n\n25\nJesper Wallstedt\n2\n117.433333\n51\n43\n0.843\n11\n8\n0.727\n\n\n27\nMads Sogaard\n2\n91.550000\n40\n32\n0.800\n14\n11\n0.786\n\n\n21\nJakub Skarek\n2\n76.150000\n39\n34\n0.872\n10\n6\n0.600\n\n\n20\nTrent Miner\n2\n91.633333\n33\n29\n0.879\n6\n4\n0.667\n\n\n24\nSebastian Cossa\n1\n45.000000\n14\n12\n0.857\n5\n3\n0.600\n\n\n0\nAkira Schmid\n1\n33.416667\n12\n12\n1.000\n3\n3\n1.000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n5\nLogan Thompson\n35\n2096.033333\n985\n904\n0.918\n266\n222\n0.835\n\n\n6\nDustin Wolf\n36\n2164.833333\n1073\n980\n0.913\n278\n235\n0.845\n\n\n7\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n8\nJoseph Woll\n32\n1886.366667\n918\n833\n0.907\n235\n190\n0.809\n\n\n9\nArvid Soderblom\n29\n1668.533333\n895\n811\n0.906\n247\n199\n0.806\n\n\n11\nPyotr Kochetkov\n37\n2196.766667\n926\n835\n0.902\n297\n254\n0.855\n\n\n13\nStuart Skinner\n40\n2321.033333\n1083\n973\n0.898\n263\n211\n0.802\n\n\n16\nUkko-Pekka Luukkonen\n43\n2448.783333\n1163\n1040\n0.894\n302\n240\n0.795\n\n\n17\nSamuel Ersson\n34\n1890.450000\n836\n747\n0.894\n196\n159\n0.811\n\n\n\n\n\n\n\n\nRGSV=DFRGFilter.loc[:,'SV%']\nRGHDSV=DFRGFilter.loc[:,'HDSV%']\nRGP=DFRGFilter.loc[:,'Player']\nPRG1=plt.scatter(RGP,RGSV)\nPRG2=plt.scatter(RGP,RGHDSV)\nplt.legend([PRG1,PRG2],['SV%','HDSV%'])\nplt.xticks(RGP,rotation=90)\nplt.ylabel('SV and HDSV Percentages')\nplt.title('Rookie Goalies and The Save They Make')\nplt.show()\n\n\n\n\n\n\n\n\n\nRGSAT=DFRGFilter.sort_values(by=['Shots Against'],ascending=[0])\ndisplay(RGSAT)\n\n\n\n\n\n\n\n\nPlayer\nGP\nTOI\nShots Against\nSaves\nSV%\nHD Shots Against\nHD Saves\nHDSV%\n\n\n\n\n16\nUkko-Pekka Luukkonen\n43\n2448.783333\n1163\n1040\n0.894\n302\n240\n0.795\n\n\n7\nLukas Dostal\n36\n2067.983333\n1111\n1011\n0.910\n305\n249\n0.816\n\n\n13\nStuart Skinner\n40\n2321.033333\n1083\n973\n0.898\n263\n211\n0.802\n\n\n6\nDustin Wolf\n36\n2164.833333\n1073\n980\n0.913\n278\n235\n0.845\n\n\n5\nLogan Thompson\n35\n2096.033333\n985\n904\n0.918\n266\n222\n0.835\n\n\n11\nPyotr Kochetkov\n37\n2196.766667\n926\n835\n0.902\n297\n254\n0.855\n\n\n8\nJoseph Woll\n32\n1886.366667\n918\n833\n0.907\n235\n190\n0.809\n\n\n9\nArvid Soderblom\n29\n1668.533333\n895\n811\n0.906\n247\n199\n0.806\n\n\n17\nSamuel Ersson\n34\n1890.450000\n836\n747\n0.894\n196\n159\n0.811\n\n\n\n\n\n\n\n\nplt.scatter(RGP,RGSAT['Shots Against'])\nplt.xticks(RGP,rotation=90)\nplt.ylabel('Shots Against')\nplt.title('Rookie Goalies and the shots taken against them')\nplt.show\n\n\n\n\n\n\n\n\n\n\nBefore moving on to other rookies I want to list my top five rookie goalies who I will consider for the Calder Memorial Trophy in conjunction with all other rookies.\n\n\nThe list is as follows:\n\n\n1) Dustin Wolf\n\n\n2) Logan Thompson\n\n\n3) Lukas Dostal\n\n\n4) Pyotr Kochetkov\n\n\n5) Joseph Woll\nFor the rest of the rookies I will initially pull all the data and filter them out by having a minimum CF value of 1100 and a minimum time on the ice of 1100 seconds. I’ll then reorder the rookie skater on ice data by PDO and CF% values in descending order. Afterward I will scale the CF% by dividing them by 100 to get them on the same scale as the PDO values and plot them against each other.\n\nDFRSIT=pd.read_csv(\"RookieSkaterOnIce.csv\")\nDFRSOIS=pd.read_csv(\"RookieSkaterIndividual.csv\")\nDFRSITFilter=DFRSIT[DFRSIT['CF']&gt;1100]\nDFRSOISFilter=DFRSOIS[DFRSOIS['TOI']&gt;1050]\nPDOROrder=DFRSITFilter.sort_values(by=['PDO'],ascending=[0])\nRCFOrder=PDOROrder.sort_values(by=['CF%'],ascending=[0])\nPDORV=PDOROrder.loc[:,'PDO']\nRCFV=RCFOrder.loc[:,'CF%']\nRGOL=DFRSOISFilter.loc[:,'Goals']\nRTAS=DFRSOISFilter.loc[:,'Total Assists']\nRTAW=DFRSOISFilter.loc[:,'Takeaways']\nRGAW=DFRSOISFilter.loc[:,'Giveaways']\nRSB=DFRSOISFilter.loc[:,'Shots Blocked']\nRTOI=DFRSOISFilter.loc[:,'TOI']\nRPRS=PDOROrder.loc[:,'Player']\nEXR=RGOL+RTAS+RTAW+RSB-RGAW\nEXRRPRS=DFRSOISFilter.loc[:,'Player']\nORP=pd.DataFrame(DFRSOISFilter['Player'])\nOP=pd.DataFrame(EXR)\npd.concat([EXR,ORP],ignore_index=[1])\nORP['EXR']=EXR\nORP['RTOI']=RTOI\nNORP=ORP.sort_values(by=['EXR'],ascending=[0])\ndisplay(NORP)\nRPS1=plt.scatter(RPRS,PDORV)\nRPS2=plt.scatter(RPRS,RCFV/100)\nplt.xticks(RPRS,rotation=90)\nplt.legend([RPS1,RPS2],['PDO','CF%'])\nplt.show()\n\n\n\n\n\n\n\n\nPlayer\nEXR\nRTOI\n\n\n\n\n9\nJake Sanderson\n142\n1447.350000\n\n\n32\nAlex Vlasic\n106\n1444.850000\n\n\n22\nJackson LaCombe\n92\n1104.983333\n\n\n19\nOwen Power\n92\n1304.666667\n\n\n1\nWyatt Johnston\n74\n1147.883333\n\n\n14\nFabian Zetterlund\n72\n1051.466667\n\n\n30\nSimon Edvinsson\n71\n1169.200000\n\n\n40\nRyker Evans\n57\n1074.066667\n\n\n16\nMatty Beniers\n56\n1131.600000\n\n\n0\nKirill Marchenko\n53\n1071.616667\n\n\n2\nMarco Rossi\n51\n1117.233333\n\n\n54\nJohnathan Kovacevic\n46\n1218.133333\n\n\n8\nMatthew Knies\n46\n1051.133333\n\n\n34\nBrock Faber\n42\n1430.333333\n\n\n27\nLuke Hughes\n40\n1084.366667\n\n\n6\nWilliam Eklund\n30\n1115.200000\n\n\n31\nMichael Kesselring\n20\n1126.350000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nI also worked to get goals,total assists, giveaways, takeaways, and shots blocked. I’ll plot these against each other.\n\nfig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5))\nplt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)\nfor ax in fig.axes:\n    plt.sca(ax)\n    plt.xticks(rotation=90)\nax1.scatter(EXRRPRS,RGOL,color='purple')\nax1.scatter(EXRRPRS,RTAS)\nax1.legend(['Goals','Total Assists'])\nax1.title.set_text('Rookie Goals and Assists')\n\nax2.scatter(EXRRPRS,RTAW,color='red')\nax2.scatter(EXRRPRS,RGAW,color='black')\nax2.scatter(EXRRPRS,RSB,color='green')\nax2.title.set_text('Rookie Takeaways, Giveaways, and Shots Blocked')\nax2.legend(['Takeaways','Giveaways','Shots Blocked'])\nplt.show()\n\n\n\n\n\n\n\n\nBased on these scatter plots, tables, and my goalie picks I’m going to assemble my list for the Calder Memorial Trophy.\n\n\nMy List for the Calder Memorial Trophy is as Follows:\n\n\n1) Kirill Marchenko\n\n\n2) Wyatt Johnston\n\n\n3) Dustin Wolf\n\n\n4) Marco Rossi\n\n\n5) Logan Thompson\nNext comes the Frank J Selke Trophy for the best overall defenseman in the league. This will include lefts and rights as well.\n\nDFRSOIS=pd.read_csv(\"SkaterOnIcestats.csv\",usecols=['Player','Position','GP','TOI','CF','CA','CF%','PDO'])\nDFilter=DFRSOIS.sort_values(by=['Position'])\nDP1=DFilter[DFilter['Position']=='D']\nDP2=DFilter[DFilter['Position']=='L']\nDP3=DFilter[DFilter['Position']=='R']\nDPFilter=DP1[DP1['GP']&gt;60]\nDP2Filter=DP2[DP2['GP']&gt;60]\nDP3Filter=DP3[DP3['GP']&gt;60]\nTOIDFilter=DPFilter[DPFilter['TOI']&gt;1300]\nTOID2Filter=DP2Filter[DP2Filter['TOI']&gt;900]\nTOID3Filter=DP3Filter[DP3Filter['TOI']&gt;550]\nDCFOrder=TOIDFilter.sort_values(by=['CF%'],ascending=[0])\nLCFOrder=TOID2Filter.sort_values(by=['CF%'],ascending=[0])\nRCFOrder=TOID3Filter.sort_values(by=['CF%'],ascending=[0])\nBD=DCFOrder.loc[:,'Player']\nBDCF=DCFOrder.loc[:,'CF%']\nBR=RCFOrder.loc[:,'Player']\nBRCF=RCFOrder.loc[:,'CF%']\nBL=LCFOrder.loc[:,'Player']\nBLCF=LCFOrder.loc[:,'CF%']\nBDD=pd.DataFrame(DCFOrder['Player'])\nBDL=pd.DataFrame(LCFOrder['Player'])\nBDR=pd.DataFrame(RCFOrder['Player'])\nDCF=pd.DataFrame(DCFOrder['CF%'])\nLCF=pd.DataFrame(LCFOrder['CF%'])\nRCF=pd.DataFrame(RCFOrder['CF%'])\npd.concat([BDD,DCF],ignore_index=[1])\nBDD['DCF']=DCF\nNBDD=BDD.sort_values(by=['DCF'],ascending=0)\npd.concat([BDL,LCF],ignore_index=[1])\nBDL['LCF']=LCF\nNBDL=BDL.sort_values(by=['LCF'],ascending=0)\npd.concat([BDR,RCF],ignore_index=[1])\nBDR['RCF']=RCF\nNBDR=BDR.sort_values(by=['RCF'],ascending=0)\nDPDOrder=TOIDFilter.sort_values(by=['PDO'],ascending=[0])\nLPDOrder=TOID2Filter.sort_values(by=['PDO'],ascending=[0])\nRPDOrder=TOID3Filter.sort_values(by=['PDO'],ascending=[0])\nDDD=DPDOrder.loc[:,'Player']\nDDP=DPDOrder.loc[:,'PDO']\nRRR=RPDOrder.loc[:,'Player']\nRRP=RPDOrder.loc[:,'PDO']\nLLL=LPDOrder.loc[:,'Player']\nLLP=LPDOrder.loc[:,'PDO']\nDPDO=pd.DataFrame(DPDOrder['PDO'])\nRPDO=pd.DataFrame(RPDOrder['PDO'])\nLPDO=pd.DataFrame(LPDOrder['PDO'])\nDPDOP=pd.DataFrame(DPDOrder['Player'])\nRPDOP=pd.DataFrame(RPDOrder['Player'])\nLPDOP=pd.DataFrame(LPDOrder['Player'])\npd.concat([DPDOP,DPDO],ignore_index=[1])\nDPDOP['PDO']=DPDO\nNDPDOP=DPDOP.sort_values(by=['PDO'],ascending=0)\npd.concat([RPDOP,RPDO],ignore_index=[1])\nRPDOP['PDO']=RPDO\nNRPDOP=RPDOP.sort_values(by=['PDO'],ascending=0)\npd.concat([LPDOP],ignore_index=[1])\nLPDOP['PDO']=LPDO\nNLPDOP=LPDOP.sort_values(by=['PDO'],ascending=0)\nDCFTOI=pd.DataFrame(DCFOrder['TOI'])\nRCFTOI=pd.DataFrame(RCFOrder['TOI'])\nLCFTOI=pd.DataFrame(LCFOrder['TOI'])\npd.concat([NBDD,DCFTOI],ignore_index=[1])\nNBDD['DCFTOI']=DCFTOI\npd.concat([NBDD,DCFTOI],ignore_index=[1])\nNBDR['RCFTOI']=RCFTOI\npd.concat([NBDD,DCFTOI],ignore_index=[1])\nNBDL['LCFTOI']=LCFTOI\nDPDOTOI=pd.DataFrame(DPDOrder['TOI'])\nRPDOTOI=pd.DataFrame(RPDOrder['TOI'])\nLPDOTOI=pd.DataFrame(LPDOrder['TOI'])\npd.concat([DPDO,DPDOTOI],ignore_index=[1])\nDPDO['DPDOTOI']=DPDOTOI\nRPDO['RPDOTOI']=RPDOTOI\nLPDO['LPDOTOI']=LPDOTOI\nOKD=BDCF\nOKR=BRCF\nOKL=BLCF\n\n\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 5))\nplt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)\nfor ax in fig.axes:\n    plt.sca(ax)\n    plt.xticks(rotation=90)\nax1.scatter(BD,BDCF,color='purple')\nax1.scatter(DDD,OKD,color='gold')\nax1.legend(['CF%','PDO'])\nax1.title.set_text('Defense CF% and PDO')\n\nax2.scatter(BL,BLCF,color='gold')\nax2.scatter(LLL,OKL,color='green')\nax2.title.set_text('Left Defense CF% and PDO')\nax2.legend(['CF%','PDO'])\n\nax3.scatter(BR,BRCF,color='gold')\nax3.scatter(RRR,OKR,color='grey')\nax3.title.set_text('Right Defense CF% and PDO')\nax3.legend(['CF%','PDO'])\n\nplt.show()\n\n\n\n\n\n\n\n\nI’m going to exclude time played from this analysis and nomination set because the scale of time on the ice between the different defensive player clusters is too large.\n\n\nMy list for the Frank J Selke Trophy is as follows:\n\n\n1) Cale Makar\n\n\n2) Jackson Blake\n\n\n3) Pierre-Luc Dubois\n\n\n4) John Carlson\n\n\n5) William Nylander\nNext will be the Hart Memorial Trophy for the player dubbed most valuable to his team. For the sake of time this will solely be based off of previously generated visualizaitons.\nThe first visulization will be for the goalies. Something important to note is that the values in the visualizations will be different for the goalies since they lack a CF% and PDO value compared to offensive and defensive players.\n\nHDSVLL=SVFF.loc[:,'HDSV%']\nSVFFL=SVFF.loc[:,'SV%']\nGP=SVFF.loc[:,'Player']\nP1=plt.scatter(GP,HDSVLL)\nP2=plt.scatter(GP,SVFFL)\nplt.xticks(GP,rotation=90)\nplt.legend([P1,P2],['HDSV%','SV%'])\nplt.title('Players and Their Save and High Danger Save Percentages')\nplt.show()\n\n\n\n\n\n\n\n\nNext will be the defensemen.\n\nPD1=plt.scatter(DP,PDOD)\nPD2=plt.scatter(DP,PDOrder['CF%']/100)\nPD3=plt.scatter(DP,PDOrder['TOI']/1000)\nplt.xticks(PDOrder['Player'],rotation=90)\nplt.legend([PD1,PD2,PD3],['PDO','CF Value','TOI (x1000)'])\nplt.ylabel('PDO and discrete CF and TOI values')\nplt.title('Players and Their Important Stats')\nplt.show()\n\n\n\n\n\n\n\n\nNow come all the defensive players including the left and right defenders.\n\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 5))\nplt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)\nfor ax in fig.axes:\n    plt.sca(ax)\n    plt.xticks(rotation=90)\nax1.scatter(BD,BDCF,color='purple')\nax1.scatter(DDD,OKD,color='gold')\nax1.legend(['CF%','PDO'])\nax1.title.set_text('Defense CF% and PDO')\n\nax2.scatter(BL,BLCF,color='gold')\nax2.scatter(LLL,OKL,color='green')\nax2.title.set_text('Left Defense CF% and PDO')\nax2.legend(['CF%','PDO'])\n\nax3.scatter(BR,BRCF,color='gold')\nax3.scatter(RRR,OKR,color='grey')\nax3.title.set_text('Right Defense CF% and PDO')\nax3.legend(['CF%','PDO'])\n\nplt.show()\n\n\n\n\n\n\n\n\nLastly, we’ll bring the rookies into the ring since they too deserve to be considered for being the most valuable player potentially.\n\nRGSV=DFRGFilter.loc[:,'SV%']\nRGHDSV=DFRGFilter.loc[:,'HDSV%']\nRGP=DFRGFilter.loc[:,'Player']\nPRG1=plt.scatter(RGP,RGSV)\nPRG2=plt.scatter(RGP,RGHDSV)\nplt.legend([PRG1,PRG2],['SV%','HDSV%'])\nplt.xticks(RGP,rotation=90)\nplt.ylabel('SV and HDSV Percentages')\nplt.title('Rookie Goalies and The Save They Make')\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5))\nplt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)\nfor ax in fig.axes:\n    plt.sca(ax)\n    plt.xticks(rotation=90)\nax1.scatter(EXRRPRS,RGOL,color='purple')\nax1.scatter(EXRRPRS,RTAS)\nax1.legend(['Goals','Total Assists'])\nax1.title.set_text('Rookie Goals and Assists')\n\nax2.scatter(EXRRPRS,RTAW,color='red')\nax2.scatter(EXRRPRS,RGAW,color='black')\nax2.scatter(EXRRPRS,RSB,color='green')\nax2.title.set_text('Rookie Takeaways, Giveaways, and Shots Blocked')\nax2.legend(['Takeaways','Giveaways','Shots Blocked'])\nplt.show()\n\n\n\n\n\n\n\n\nNow that all of the previously generated visualiztions are here, it’s time to get a new one added to the mix. Essentially it’ll be just like the Rookie Goals and Assists set of visualizations but for the more seasoned skaters. TOI will be divided by 100 seconds to properly scale it and discreitze it so it can be more easily visualized.\n\nDFSIT = pd.read_csv(\"SkaterOnIcestats.csv\")\nDFSITFilter=DFSIT[DFSIT['CF']&gt;1550]\nPDOSOrder=DFSITFilter.sort_values(by=['PDO'],ascending=[0])\nSCFOrder=PDOSOrder.sort_values(by=['CF%'],ascending=[0])\nPDOSV=PDOSOrder.loc[:,'PDO']\nSCFV=SCFOrder.loc[:,'CF%']/100\nSGOL=PDOSOrder.loc[:,'GF%']\nSTAS=DFSITFilter.loc[:,'FA']\nSTAHDG=DFSITFilter.loc[:,'HDGF%']\nSGAW=DFSITFilter.loc[:,'GA']\nSSB=DFSITFilter.loc[:,'On-Ice SV%']\nSTOI=DFSITFilter.loc[:,'TOI']/100\nSPRS=PDOSOrder.loc[:,'Player']\nEXSRPRS=DFSITFilter.loc[:,'Player']\nOSP=pd.DataFrame(DFSITFilter['Player'])\n\n\nfig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5))\nplt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)\nfor ax in fig.axes:\n    plt.sca(ax)\n    plt.xticks(rotation=90)\nax1.scatter(SPRS,PDOSV,color='purple')\nax1.scatter(SPRS,SCFV)\nax1.legend(['Goals','high Danger Goals'])\nax1.title.set_text('PDO and CF')\n\nax2.scatter(EXSRPRS,SSB,color='red')\nax2.scatter(EXSRPRS,STAHDG,color='black')\nax2.scatter(EXSRPRS,STOI,color='green')\nax2.title.set_text('On-Ice SV%, HDGF%, and TOI')\nax2.legend(['On-Ice SV%','HDGF%','TOI (x100)'])\nplt.show()\n\n\n\n\n\n\n\n\n\n\nNow it comes time to make my picks for the Hart Memorial Trophy. The list is as follows:\n\n\n1) Connor Hellbuyck\n\n\n2) Zach Weresnki\n\n\n3) Kirill Marchenko\n\n\n4) Dustin Wolf\n\n\n5) John Carlson\nLastly comes the Lady Byng trophy given to the athlete who displays the best sportsmanship and skills. Information related to skill is going to be pulled from the Hart Memorial Trophy visualizations above, but for sportsmanship the primary metrics being looked at will be penalties incurred by skaters.\n\nRPEN=pd.read_csv(\"RookieSkaterIndividual.csv\",usecols=['Player','TOI','PIM','Total Penalties','Minor','Major','Misconduct','Penalties Drawn'])\nSPEN=pd.read_csv(\"SkaterIndividualstats.csv\",usecols=['Player','TOI','PIM','Total Penalties','Minor','Major','Misconduct','Penalties Drawn'])\nSPEN.sort_values(by=['Major'],ascending=[1])\nSPENFilter=SPEN[SPEN['TOI']&gt;1400]\ndisplay(SPENFilter)\nSPPS=SPENFilter.loc[:,'Player']\nSPIM=SPENFilter.loc[:,'PIM']\nSTP=SPENFilter.loc[:,'Total Penalties']\nSMI=SPENFilter.loc[:,'Minor']\nSMJ=SPENFilter.loc[:,'Major']\nSMC=SPENFilter.loc[:,'Misconduct']\nSPD=SPENFilter.loc[:,'Penalties Drawn']\nSPENT=SPIM+STP+SMI+SMJ+SMC+SPD\nSPENT1=pd.DataFrame(SPENT)\nSPPS1=pd.DataFrame(SPPS)\nAG=pd.concat([SPENT,SPPS],ignore_index=[1])\nSPPS1['SPENT1']=SPENT1\nSPPS1.sort_values(by=['SPENT1'],ascending=[1])\n\n\n\n\n\n\n\n\nPlayer\nTOI\nPIM\nTotal Penalties\nMinor\nMajor\nMisconduct\nPenalties Drawn\n\n\n\n\n15\nCale Makar\n1574.800000\n12\n6\n6\n0\n0\n18\n\n\n19\nZach Werenski\n1586.366667\n29\n13\n12\n1\n0\n13\n\n\n68\nJosh Morrissey\n1445.800000\n22\n11\n11\n0\n0\n11\n\n\n81\nEvan Bouchard\n1414.666667\n22\n11\n11\n0\n0\n18\n\n\n84\nErik Karlsson\n1466.800000\n18\n9\n9\n0\n0\n7\n\n\n112\nJake Sanderson\n1447.350000\n10\n5\n5\n0\n0\n7\n\n\n115\nJohn Carlson\n1452.316667\n18\n9\n9\n0\n0\n7\n\n\n122\nMikhail Sergachev\n1430.150000\n20\n10\n10\n0\n0\n5\n\n\n139\nMoritz Seider\n1515.966667\n30\n15\n15\n0\n0\n12\n\n\n150\nColton Parayko\n1455.716667\n8\n4\n4\n0\n0\n5\n\n\n157\nMacKenzie Weegar\n1427.033333\n27\n12\n11\n1\n0\n12\n\n\n195\nDevon Toews\n1413.983333\n16\n7\n7\n0\n0\n9\n\n\n202\nMike Matheson\n1461.600000\n43\n16\n14\n1\n1\n12\n\n\n207\nIvan Provorov\n1413.683333\n18\n9\n9\n0\n0\n9\n\n\n219\nTravis Sanheim\n1496.050000\n28\n14\n14\n0\n0\n15\n\n\n264\nAlex Vlasic\n1444.850000\n10\n5\n5\n0\n0\n5\n\n\n267\nBrock Faber\n1430.333333\n19\n8\n7\n1\n0\n9\n\n\n277\nGustav Forsling\n1418.650000\n10\n5\n5\n0\n0\n6\n\n\n298\nRasmus Andersson\n1447.283333\n50\n21\n20\n0\n1\n18\n\n\n316\nVladislav Gavrikov\n1406.100000\n14\n7\n7\n0\n0\n5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlayer\nSPENT1\n\n\n\n\n150\nColton Parayko\n21\n\n\n264\nAlex Vlasic\n25\n\n\n277\nGustav Forsling\n26\n\n\n112\nJake Sanderson\n27\n\n\n316\nVladislav Gavrikov\n33\n\n\n195\nDevon Toews\n39\n\n\n15\nCale Makar\n42\n\n\n84\nErik Karlsson\n43\n\n\n115\nJohn Carlson\n43\n\n\n267\nBrock Faber\n44\n\n\n207\nIvan Provorov\n45\n\n\n122\nMikhail Sergachev\n45\n\n\n68\nJosh Morrissey\n55\n\n\n81\nEvan Bouchard\n62\n\n\n157\nMacKenzie Weegar\n63\n\n\n19\nZach Werenski\n68\n\n\n219\nTravis Sanheim\n71\n\n\n139\nMoritz Seider\n72\n\n\n202\nMike Matheson\n87\n\n\n298\nRasmus Andersson\n110\n\n\n\n\n\n\n\nThe players with the best sportmanship will have the lowest SPENT1 values above. The problem is that there are tons of them with a score of 0. I then sorted by TOI with a minimum TOI of 1500 required. From here I looked at more seasoned players who were in the above nominations. These include Cale Makar, Erik Karlsson, John Carlson, and Zach Werenski. Next will come the rookies.\n\nRPENFilter=RPEN[RPEN['TOI']&gt;1000]\ndisplay(RPENFilter)\nRPPS=RPENFilter.loc[:,'Player']\nRPIM=RPENFilter.loc[:,'PIM']\nRTP=RPENFilter.loc[:,'Total Penalties']\nRMI=RPENFilter.loc[:,'Minor']\nRMJ=RPENFilter.loc[:,'Major']\nRMC=RPENFilter.loc[:,'Misconduct']\nRPD=RPENFilter.loc[:,'Penalties Drawn']\nRPENT=RPIM+RTP+RMI+RMJ+RMC+RPD\nRPENT1=pd.DataFrame(RPENT)\nRPPS1=pd.DataFrame(RPPS)\nRG=pd.concat([RPENT,RPPS],ignore_index=[1])\nRPPS1['RPENT1']=RPENT1\nRPPS1.sort_values(by=['RPENT1'],ascending=[1])\n\n\n\n\n\n\n\n\nPlayer\nTOI\nPIM\nTotal Penalties\nMinor\nMajor\nMisconduct\nPenalties Drawn\n\n\n\n\n0\nKirill Marchenko\n1071.616667\n14\n7\n7\n0\n0\n13\n\n\n1\nWyatt Johnston\n1147.883333\n12\n6\n6\n0\n0\n10\n\n\n2\nMarco Rossi\n1117.233333\n24\n12\n12\n0\n0\n16\n\n\n3\nJJ Peterka\n1029.950000\n24\n8\n7\n0\n1\n11\n\n\n5\nDylan Holloway\n1031.983333\n10\n5\n5\n0\n0\n8\n\n\n6\nWilliam Eklund\n1115.200000\n22\n7\n6\n0\n1\n14\n\n\n8\nMatthew Knies\n1051.133333\n26\n13\n13\n0\n0\n14\n\n\n9\nJake Sanderson\n1447.350000\n10\n5\n5\n0\n0\n7\n\n\n14\nFabian Zetterlund\n1051.466667\n10\n5\n5\n0\n0\n17\n\n\n16\nMatty Beniers\n1131.600000\n12\n6\n6\n0\n0\n17\n\n\n19\nOwen Power\n1304.666667\n12\n6\n6\n0\n0\n6\n\n\n22\nJackson LaCombe\n1104.983333\n18\n9\n9\n0\n0\n4\n\n\n27\nLuke Hughes\n1084.366667\n14\n7\n7\n0\n0\n5\n\n\n30\nSimon Edvinsson\n1169.200000\n36\n14\n13\n0\n1\n8\n\n\n31\nMichael Kesselring\n1126.350000\n65\n20\n15\n3\n2\n13\n\n\n32\nAlex Vlasic\n1444.850000\n10\n5\n5\n0\n0\n5\n\n\n34\nBrock Faber\n1430.333333\n19\n8\n7\n1\n0\n9\n\n\n40\nRyker Evans\n1074.066667\n18\n9\n9\n0\n0\n7\n\n\n43\nJordan Spence\n1010.166667\n16\n8\n8\n0\n0\n2\n\n\n54\nJohnathan Kovacevic\n1218.133333\n47\n19\n16\n3\n0\n9\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlayer\nRPENT1\n\n\n\n\n32\nAlex Vlasic\n25\n\n\n9\nJake Sanderson\n27\n\n\n5\nDylan Holloway\n28\n\n\n19\nOwen Power\n30\n\n\n27\nLuke Hughes\n33\n\n\n1\nWyatt Johnston\n34\n\n\n43\nJordan Spence\n34\n\n\n14\nFabian Zetterlund\n37\n\n\n22\nJackson LaCombe\n40\n\n\n0\nKirill Marchenko\n41\n\n\n16\nMatty Beniers\n41\n\n\n40\nRyker Evans\n43\n\n\n34\nBrock Faber\n44\n\n\n6\nWilliam Eklund\n50\n\n\n3\nJJ Peterka\n51\n\n\n2\nMarco Rossi\n64\n\n\n8\nMatthew Knies\n66\n\n\n30\nSimon Edvinsson\n72\n\n\n54\nJohnathan Kovacevic\n94\n\n\n31\nMichael Kesselring\n118\n\n\n\n\n\n\n\n\nCale=42\nErik=43\nJohn=43\nZach=68\nAlex=25\nWyatt=34\nKirill=41\n\nSome names seen previously include Alex Vlasic, Wyatt Johnston, and Kirill Marchenko. Next comes time to compare these players specifically. Interestingly enough the rookies have lower incursion scores which is the sum of major and minor penalties, penalties drawn, PIM, total penalties, and misconduct.\n\n\nMy list for the Lady Byng Trophy is as follows:\n\n\n1) Cale Makar\n\n\n2) Kirill Marchenko\n\n\n3) Alex Vlasic\n\n\n4) Erik Karlsson\n\n\n5) John Carlson"
  }
]