<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ian">

<title>Some Ice Sport Doohickey – Baden-520-Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Baden-520-Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Bayern1090"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Some Ice Sport Doohickey</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Nuh uh</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Ian </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<pre><code>import plotly.express as px
import matplotlib.pyplot as plt
import pandas as pd
import statistics
from matplotlib import cm
import csv
import tidypandas as tp
DFGV=pd.read_csv("Goalies.csv", usecols=['Player','GP','TOI','Shots Against','Saves','SV%','HD Shots Against','HD Saves','HDSV%'])
#print(DFGV)
DFSIT = pd.read_csv("SkaterIndividualstats.csv")
#print(DFSIT)
DFSOIS=pd.read_csv("SkaterOnIcestats.csv")
#print(DFG)
DFRG=pd.read_csv("RookieGoalies.csv")
#print(DFRG)
DFRSIT=pd.read_csv("RookieSkaterOnIce.csv")
#print(DFRSIT)
DFRSOIS=pd.read_csv("RookieSkaterIndividual.csv")
#print(DFRSOIS)</code></pre>
<p>Let’s start with the Vezina trophy for the best goalie.</p>
<pre><code>DFGV=pd.read_csv("Goalies.csv", usecols=['Player','GP','TOI','Shots Against','Saves','SV%','HD Shots Against','HD Saves','HDSV%'])</code></pre>
<p>First I will filter out goalies who have fewer than 1000 saves</p>
<pre><code>filtered_DFGV = DFGV[DFGV['Saves'] &gt;1000]
display(filtered_DFGV)</code></pre>
<p>Next I’ll sort by the High Danger Save Percentages</p>
<pre><code>HDOrder=filtered_DFGV.sort_values(by=['HDSV%'], ascending=[0])
display(HDOrder)</code></pre>
<p>One last order that I’m going to perform is to order goalies by save percentage before doing further filtering</p>
<pre><code>SVOrder=filtered_DFGV.sort_values(by=['SV%'], ascending=[0])
display(SVOrder)</code></pre>
<p>Now I’m going to run another filter on the data. This time I will set a filter that clears out anyone who has a High Danger Save Percentage lower than 80%.</p>
<pre><code>HDSVFilter=filtered_DFGV[filtered_DFGV['HDSV%']&gt;0.8]
display(HDSVFilter)</code></pre>
<p>Next is a second filter to filter out those who have a saver percentage beneath 90%.</p>
<pre><code>SVFilter=HDSVFilter[HDSVFilter['SV%']&gt;0.9]
display(SVFilter)</code></pre>
<p>The next two reorderings will be first by HDSV percentage and then by SV percentage</p>
<pre><code>HDSVF=SVFilter.sort_values(by=['HDSV%'], ascending=[0])
display(HDSVF)</code></pre>
<pre><code>SVFF=SVFilter.sort_values(by=['SV%'], ascending=[0])
display(SVFF)</code></pre>
<pre><code>SAL=SVFilter.sort_values(by=['Shots Against'], ascending=[0])</code></pre>
<p>Firstly, I will plot players and their total number of shots against.</p>
<pre><code>plt.scatter(SAL['Player'],SAL['Shots Against'])
plt.xticks(SAL['Player'],rotation=90)
plt.ylabel('Shots Against')
plt.title('Players and The Shots Against Them')
plt.show</code></pre>
<p>Next I will plot players and their save percentages and high danger save percentages.</p>
<pre><code>HDSVLL=SVFF.loc[:,'HDSV%']
SVFFL=SVFF.loc[:,'SV%']
GP=SVFF.loc[:,'Player']
P1=plt.scatter(GP,HDSVLL)
P2=plt.scatter(GP,SVFFL)
plt.xticks(GP,rotation=90)
plt.legend([P1,P2],['HDSV%','SV%'])
plt.title('Players and Their Save and High Danger Save Percentages')
plt.show()</code></pre>
<section id="from-these-plots-and-the-tables-generated-in-filtering-and-ordering-the-data-i-will-create-my-ticket-for-the-vezina-trophy." class="level1">
<h1>From these plots and the tables generated in filtering and ordering the data I will create my ticket for the Vezina Trophy.</h1>
</section>
<section id="my-ticket-is-as-follows" class="level1">
<h1>My ticket is as follows:</h1>
</section>
<section id="connor-hellebuyck" class="level1">
<h1>1) Connor Hellebuyck</h1>
</section>
<section id="andrei-vasilevskiy" class="level1">
<h1>2) Andrei Vasilevskiy</h1>
</section>
<section id="igor-shesterkin" class="level1">
<h1>3) Igor Shesterkin</h1>
</section>
<section id="mackenzie-blackwood" class="level1">
<h1>4) Mackenzie Blackwood</h1>
</section>
<section id="filip-gustavsson" class="level1">
<h1>5) Filip Gustavsson</h1>
<p>The next trophy is the James Norris Memorial trophy for the best overall defenseman for the position.</p>
<p>The first thing I plan to do is run a filter on the data. For defesnsive players and other pertinent information like GP, TOI, CF, CA, CF% and PDO as metrics for their performance.</p>
<pre><code>DFRSOIS=pd.read_csv("SkaterOnIcestats.csv",usecols=['Player','Position','GP','TOI','CF','CA','CF%','PDO'])
DFilter=DFRSOIS.sort_values(by=['Position'])
D=DFilter[DFilter['Position']=='D']
display(D)</code></pre>
<p>Next I will run a series of filters to filter for time on the ice and games played.</p>
<pre><code>DPFilter=D[D['GP']&gt;60]
TOIDFilter=DPFilter[DPFilter['TOI']&gt;1300]
display(TOIDFilter)</code></pre>
<p>I will reorder based on the total time on the ice that players are getting.</p>
<pre><code>TOIDOrder=TOIDFilter.sort_values(by=['TOI'],ascending=[0])
display(TOIDOrder)</code></pre>
<p>From here I can see that CF and CA values don’t directly correlate with time on the ice. From here I will reorder based on the CF% as a value greater than 55% is considered to be the best of the best.</p>
<pre><code>CFOrder=TOIDOrder.sort_values(by=['CF%'],ascending=[0])
display(CFOrder)</code></pre>
<pre><code>CF=CFOrder.loc[:,'CF']
TOID=CFOrder.loc[:,'TOI']
DP=CFOrder.loc[:,'Player']
Games=CFOrder.loc[:'GP']
plt.scatter(TOIDOrder['Player'],TOIDOrder['TOI'])
plt.xticks(TOIDOrder['Player'],rotation=90)
plt.ylabel('TIO(seconds)')
plt.title('Players and Their Time on the Ice')
plt.show</code></pre>
<p>One final reordering will be based on PDO values as a value greater than one means that players are playing better than expected.</p>
<pre><code>PDOrder=TOIDOrder.sort_values(by=['PDO'],ascending=[0])
PDOD=PDOrder.loc[:,'PDO']
display(PDOrder)</code></pre>
<p>The following plot will plot players PDO values and their CF values which are their CF percentages divided by 100% to get them to a discrete decimal value scale. I also took the players’ time on the ice and divided it by 1000 seconds to get a discrete value for how many seconds they spend on the ice with the basis being 1000 seconds.</p>
<pre><code>PD1=plt.scatter(DP,PDOD)
PD2=plt.scatter(DP,PDOrder['CF%']/100)
PD3=plt.scatter(DP,PDOrder['TOI']/1000)
plt.xticks(PDOrder['Player'],rotation=90)
plt.legend([PD1,PD2,PD3],['PDO','CF Value','TOI (x1000)'])
plt.ylabel('PDO and discrete CF and TOI values')
plt.title('Players and Their Important Stats')
plt.show()</code></pre>
</section>
<section id="based-on-the-above-visualization-my-ticket-for-the-james-norris-memorial-trophy-is-as-follows" class="level1">
<h1>Based on the above visualization my ticket for the James Norris Memorial Trophy is as follows:</h1>
</section>
<section id="lane-hutson" class="level1">
<h1>1) Lane Hutson</h1>
</section>
<section id="erik-karlsson" class="level1">
<h1>2) Erik Karlsson</h1>
</section>
<section id="john-carlson" class="level1">
<h1>3) John Carlson</h1>
</section>
<section id="alex-vlasic" class="level1">
<h1>4) Alex Vlasic</h1>
</section>
<section id="brent-burns" class="level1">
<h1>5) Brent Burns</h1>
<p>The next trophy is going to be the Calder Memorial Trophy which goes to the best rookie in the league. I’m going to divide the data for rookies between goalies and non-goalies.</p>
<p>First comes the rookie goalies. The data will be reordered to show who has had the most shots taken against them. Then the first filter will be applied. This will be based on games played.</p>
<pre><code>DFRG=pd.read_csv("RookieGoalies.csv",usecols=['Player','GP','TOI','Shots Against','Saves','SV%','HD Shots Against','HD Saves','HDSV%'])
DFRGFilter=DFRG[DFRG['GP']&gt;25]
DFRGSAO=DFRG.sort_values(by=['Shots Against'],ascending=[0])
display(DFRGSAO,DFRGFilter)</code></pre>
<pre><code>RGSV=DFRGFilter.loc[:,'SV%']
RGHDSV=DFRGFilter.loc[:,'HDSV%']
RGP=DFRGFilter.loc[:,'Player']
PRG1=plt.scatter(RGP,RGSV)
PRG2=plt.scatter(RGP,RGHDSV)
plt.legend([PRG1,PRG2],['SV%','HDSV%'])
plt.xticks(RGP,rotation=90)
plt.ylabel('SV and HDSV Percentages')
plt.title('Rookie Goalies and The Save They Make')
plt.show()</code></pre>
<pre><code>RGSAT=DFRGFilter.sort_values(by=['Shots Against'],ascending=[0])
display(RGSAT)</code></pre>
<pre><code>plt.scatter(RGP,RGSAT['Shots Against'])
plt.xticks(RGP,rotation=90)
plt.ylabel('Shots Against')
plt.title('Rookie Goalies and the shots taken against them')
plt.show</code></pre>
</section>
<section id="before-moving-on-to-other-rookies-i-want-to-list-my-top-five-rookie-goalies-who-i-will-consider-for-the-calder-memorial-trophy-in-conjunction-with-all-other-rookies." class="level1">
<h1>Before moving on to other rookies I want to list my top five rookie goalies who I will consider for the Calder Memorial Trophy in conjunction with all other rookies.</h1>
</section>
<section id="the-list-is-as-follows" class="level1">
<h1>The list is as follows:</h1>
</section>
<section id="dustin-wolf" class="level1">
<h1>1) Dustin Wolf</h1>
</section>
<section id="logan-thompson" class="level1">
<h1>2) Logan Thompson</h1>
</section>
<section id="lukas-dostal" class="level1">
<h1>3) Lukas Dostal</h1>
</section>
<section id="pyotr-kochetkov" class="level1">
<h1>4) Pyotr Kochetkov</h1>
</section>
<section id="joseph-woll" class="level1">
<h1>5) Joseph Woll</h1>
<p>For the rest of the rookies I will initially pull all the data and filter them out by having a minimum CF value of 1100 and a minimum time on the ice of 1100 seconds. I’ll then reorder the rookie skater on ice data by PDO and CF% values in descending order. Afterward I will scale the CF% by dividing them by 100 to get them on the same scale as the PDO values and plot them against each other.</p>
<pre><code>DFRSIT=pd.read_csv("RookieSkaterOnIce.csv")
DFRSOIS=pd.read_csv("RookieSkaterIndividual.csv")
DFRSITFilter=DFRSIT[DFRSIT['CF']&gt;1100]
DFRSOISFilter=DFRSOIS[DFRSOIS['TOI']&gt;1050]
PDOROrder=DFRSITFilter.sort_values(by=['PDO'],ascending=[0])
RCFOrder=PDOROrder.sort_values(by=['CF%'],ascending=[0])
PDORV=PDOROrder.loc[:,'PDO']
RCFV=RCFOrder.loc[:,'CF%']
RGOL=DFRSOISFilter.loc[:,'Goals']
RTAS=DFRSOISFilter.loc[:,'Total Assists']
RTAW=DFRSOISFilter.loc[:,'Takeaways']
RGAW=DFRSOISFilter.loc[:,'Giveaways']
RSB=DFRSOISFilter.loc[:,'Shots Blocked']
RTOI=DFRSOISFilter.loc[:,'TOI']
RPRS=PDOROrder.loc[:,'Player']
EXR=RGOL+RTAS+RTAW+RSB-RGAW
EXRRPRS=DFRSOISFilter.loc[:,'Player']
ORP=pd.DataFrame(DFRSOISFilter['Player'])
OP=pd.DataFrame(EXR)
pd.concat([EXR,ORP],ignore_index=[1])
ORP['EXR']=EXR
ORP['RTOI']=RTOI
NORP=ORP.sort_values(by=['EXR'],ascending=[0])
display(NORP)
RPS1=plt.scatter(RPRS,PDORV)
RPS2=plt.scatter(RPRS,RCFV/100)
plt.xticks(RPRS,rotation=90)
plt.legend([RPS1,RPS2],['PDO','CF%'])
plt.show()</code></pre>
<p>I also worked to get goals,total assists, giveaways, takeaways, and shots blocked. I’ll plot these against each other.</p>
<pre><code>fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5))
plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)
for ax in fig.axes:
    plt.sca(ax)
    plt.xticks(rotation=90)
ax1.scatter(EXRRPRS,RGOL,color='purple')
ax1.scatter(EXRRPRS,RTAS)
ax1.legend(['Goals','Total Assists'])
ax1.title.set_text('Rookie Goals and Assists')

ax2.scatter(EXRRPRS,RTAW,color='red')
ax2.scatter(EXRRPRS,RGAW,color='black')
ax2.scatter(EXRRPRS,RSB,color='green')
ax2.title.set_text('Rookie Takeaways, Giveaways, and Shots Blocked')
ax2.legend(['Takeaways','Giveaways','Shots Blocked'])
plt.show()</code></pre>
<p>Based on these scatter plots, tables, and my goalie picks I’m going to assemble my list for the Calder Memorial Trophy.</p>
</section>
<section id="my-list-for-the-calder-memorial-trophy-is-as-follows" class="level1">
<h1>My List for the Calder Memorial Trophy is as Follows:</h1>
</section>
<section id="kirill-marchenko" class="level1">
<h1>1) Kirill Marchenko</h1>
</section>
<section id="wyatt-johnston" class="level1">
<h1>2) Wyatt Johnston</h1>
</section>
<section id="dustin-wolf-1" class="level1">
<h1>3) Dustin Wolf</h1>
</section>
<section id="marco-rossi" class="level1">
<h1>4) Marco Rossi</h1>
</section>
<section id="logan-thompson-1" class="level1">
<h1>5) Logan Thompson</h1>
<p>Next comes the Frank J Selke Trophy for the best overall defenseman in the league. This will include lefts and rights as well.</p>
<pre><code>DFRSOIS=pd.read_csv("SkaterOnIcestats.csv",usecols=['Player','Position','GP','TOI','CF','CA','CF%','PDO'])
DFilter=DFRSOIS.sort_values(by=['Position'])
DP1=DFilter[DFilter['Position']=='D']
DP2=DFilter[DFilter['Position']=='L']
DP3=DFilter[DFilter['Position']=='R']
DPFilter=DP1[DP1['GP']&gt;60]
DP2Filter=DP2[DP2['GP']&gt;60]
DP3Filter=DP3[DP3['GP']&gt;60]
TOIDFilter=DPFilter[DPFilter['TOI']&gt;1300]
TOID2Filter=DP2Filter[DP2Filter['TOI']&gt;900]
TOID3Filter=DP3Filter[DP3Filter['TOI']&gt;550]
DCFOrder=TOIDFilter.sort_values(by=['CF%'],ascending=[0])
LCFOrder=TOID2Filter.sort_values(by=['CF%'],ascending=[0])
RCFOrder=TOID3Filter.sort_values(by=['CF%'],ascending=[0])
BD=DCFOrder.loc[:,'Player']
BDCF=DCFOrder.loc[:,'CF%']
BR=RCFOrder.loc[:,'Player']
BRCF=RCFOrder.loc[:,'CF%']
BL=LCFOrder.loc[:,'Player']
BLCF=LCFOrder.loc[:,'CF%']
BDD=pd.DataFrame(DCFOrder['Player'])
BDL=pd.DataFrame(LCFOrder['Player'])
BDR=pd.DataFrame(RCFOrder['Player'])
DCF=pd.DataFrame(DCFOrder['CF%'])
LCF=pd.DataFrame(LCFOrder['CF%'])
RCF=pd.DataFrame(RCFOrder['CF%'])
pd.concat([BDD,DCF],ignore_index=[1])
BDD['DCF']=DCF
NBDD=BDD.sort_values(by=['DCF'],ascending=0)
pd.concat([BDL,LCF],ignore_index=[1])
BDL['LCF']=LCF
NBDL=BDL.sort_values(by=['LCF'],ascending=0)
pd.concat([BDR,RCF],ignore_index=[1])
BDR['RCF']=RCF
NBDR=BDR.sort_values(by=['RCF'],ascending=0)
DPDOrder=TOIDFilter.sort_values(by=['PDO'],ascending=[0])
LPDOrder=TOID2Filter.sort_values(by=['PDO'],ascending=[0])
RPDOrder=TOID3Filter.sort_values(by=['PDO'],ascending=[0])
DDD=DPDOrder.loc[:,'Player']
DDP=DPDOrder.loc[:,'PDO']
RRR=RPDOrder.loc[:,'Player']
RRP=RPDOrder.loc[:,'PDO']
LLL=LPDOrder.loc[:,'Player']
LLP=LPDOrder.loc[:,'PDO']
DPDO=pd.DataFrame(DPDOrder['PDO'])
RPDO=pd.DataFrame(RPDOrder['PDO'])
LPDO=pd.DataFrame(LPDOrder['PDO'])
DPDOP=pd.DataFrame(DPDOrder['Player'])
RPDOP=pd.DataFrame(RPDOrder['Player'])
LPDOP=pd.DataFrame(LPDOrder['Player'])
pd.concat([DPDOP,DPDO],ignore_index=[1])
DPDOP['PDO']=DPDO
NDPDOP=DPDOP.sort_values(by=['PDO'],ascending=0)
pd.concat([RPDOP,RPDO],ignore_index=[1])
RPDOP['PDO']=RPDO
NRPDOP=RPDOP.sort_values(by=['PDO'],ascending=0)
pd.concat([LPDOP],ignore_index=[1])
LPDOP['PDO']=LPDO
NLPDOP=LPDOP.sort_values(by=['PDO'],ascending=0)
DCFTOI=pd.DataFrame(DCFOrder['TOI'])
RCFTOI=pd.DataFrame(RCFOrder['TOI'])
LCFTOI=pd.DataFrame(LCFOrder['TOI'])
pd.concat([NBDD,DCFTOI],ignore_index=[1])
NBDD['DCFTOI']=DCFTOI
pd.concat([NBDD,DCFTOI],ignore_index=[1])
NBDR['RCFTOI']=RCFTOI
pd.concat([NBDD,DCFTOI],ignore_index=[1])
NBDL['LCFTOI']=LCFTOI
DPDOTOI=pd.DataFrame(DPDOrder['TOI'])
RPDOTOI=pd.DataFrame(RPDOrder['TOI'])
LPDOTOI=pd.DataFrame(LPDOrder['TOI'])
pd.concat([DPDO,DPDOTOI],ignore_index=[1])
DPDO['DPDOTOI']=DPDOTOI
RPDO['RPDOTOI']=RPDOTOI
LPDO['LPDOTOI']=LPDOTOI
OKD=BDCF
OKR=BRCF
OKL=BLCF</code></pre>
<pre><code>fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 5))
plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)
for ax in fig.axes:
    plt.sca(ax)
    plt.xticks(rotation=90)
ax1.scatter(BD,BDCF,color='purple')
ax1.scatter(DDD,OKD,color='gold')
ax1.legend(['CF%','PDO'])
ax1.title.set_text('Defense CF% and PDO')

ax2.scatter(BL,BLCF,color='gold')
ax2.scatter(LLL,OKL,color='green')
ax2.title.set_text('Left Defense CF% and PDO')
ax2.legend(['CF%','PDO'])

ax3.scatter(BR,BRCF,color='gold')
ax3.scatter(RRR,OKR,color='grey')
ax3.title.set_text('Right Defense CF% and PDO')
ax3.legend(['CF%','PDO'])

plt.show()</code></pre>
<p>I’m going to exclude time played from this analysis and nomination set because the scale of time on the ice between the different defensive player clusters is too large.</p>
</section>
<section id="my-list-for-the-frank-j-selke-trophy-is-as-follows" class="level1">
<h1>My list for the Frank J Selke Trophy is as follows:</h1>
</section>
<section id="cale-makar" class="level1">
<h1>1) Cale Makar</h1>
</section>
<section id="jackson-blake" class="level1">
<h1>2) Jackson Blake</h1>
</section>
<section id="pierre-luc-dubois" class="level1">
<h1>3) Pierre-Luc Dubois</h1>
</section>
<section id="john-carlson-1" class="level1">
<h1>4) John Carlson</h1>
</section>
<section id="william-nylander" class="level1">
<h1>5) William Nylander</h1>
<p>Next will be the Hart Memorial Trophy for the player dubbed most valuable to his team. For the sake of time this will solely be based off of previously generated visualizaitons.</p>
<p>The first visulization will be for the goalies. Something important to note is that the values in the visualizations will be different for the goalies since they lack a CF% and PDO value compared to offensive and defensive players.</p>
<pre><code>HDSVLL=SVFF.loc[:,'HDSV%']
SVFFL=SVFF.loc[:,'SV%']
GP=SVFF.loc[:,'Player']
P1=plt.scatter(GP,HDSVLL)
P2=plt.scatter(GP,SVFFL)
plt.xticks(GP,rotation=90)
plt.legend([P1,P2],['HDSV%','SV%'])
plt.title('Players and Their Save and High Danger Save Percentages')
plt.show()</code></pre>
<p>Next will be the defensemen.</p>
<pre><code>PD1=plt.scatter(DP,PDOD)
PD2=plt.scatter(DP,PDOrder['CF%']/100)
PD3=plt.scatter(DP,PDOrder['TOI']/1000)
plt.xticks(PDOrder['Player'],rotation=90)
plt.legend([PD1,PD2,PD3],['PDO','CF Value','TOI (x1000)'])
plt.ylabel('PDO and discrete CF and TOI values')
plt.title('Players and Their Important Stats')
plt.show()</code></pre>
<p>Now come all the defensive players including the left and right defenders.</p>
<pre><code>fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 5))
plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)
for ax in fig.axes:
    plt.sca(ax)
    plt.xticks(rotation=90)
ax1.scatter(BD,BDCF,color='purple')
ax1.scatter(DDD,OKD,color='gold')
ax1.legend(['CF%','PDO'])
ax1.title.set_text('Defense CF% and PDO')

ax2.scatter(BL,BLCF,color='gold')
ax2.scatter(LLL,OKL,color='green')
ax2.title.set_text('Left Defense CF% and PDO')
ax2.legend(['CF%','PDO'])

ax3.scatter(BR,BRCF,color='gold')
ax3.scatter(RRR,OKR,color='grey')
ax3.title.set_text('Right Defense CF% and PDO')
ax3.legend(['CF%','PDO'])

plt.show()</code></pre>
<p>Lastly, we’ll bring the rookies into the ring since they too deserve to be considered for being the most valuable player potentially.</p>
<pre><code>RGSV=DFRGFilter.loc[:,'SV%']
RGHDSV=DFRGFilter.loc[:,'HDSV%']
RGP=DFRGFilter.loc[:,'Player']
PRG1=plt.scatter(RGP,RGSV)
PRG2=plt.scatter(RGP,RGHDSV)
plt.legend([PRG1,PRG2],['SV%','HDSV%'])
plt.xticks(RGP,rotation=90)
plt.ylabel('SV and HDSV Percentages')
plt.title('Rookie Goalies and The Save They Make')
plt.show()</code></pre>
<pre><code>fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5))
plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)
for ax in fig.axes:
    plt.sca(ax)
    plt.xticks(rotation=90)
ax1.scatter(EXRRPRS,RGOL,color='purple')
ax1.scatter(EXRRPRS,RTAS)
ax1.legend(['Goals','Total Assists'])
ax1.title.set_text('Rookie Goals and Assists')

ax2.scatter(EXRRPRS,RTAW,color='red')
ax2.scatter(EXRRPRS,RGAW,color='black')
ax2.scatter(EXRRPRS,RSB,color='green')
ax2.title.set_text('Rookie Takeaways, Giveaways, and Shots Blocked')
ax2.legend(['Takeaways','Giveaways','Shots Blocked'])
plt.show()</code></pre>
<p>Now that all of the previously generated visualiztions are here, it’s time to get a new one added to the mix. Essentially it’ll be just like the Rookie Goals and Assists set of visualizations but for the more seasoned skaters. TOI will be divided by 100 seconds to properly scale it and discreitze it so it can be more easily visualized.</p>
<pre><code>DFSIT = pd.read_csv("SkaterOnIcestats.csv")
DFSITFilter=DFSIT[DFSIT['CF']&gt;1550]
PDOSOrder=DFSITFilter.sort_values(by=['PDO'],ascending=[0])
SCFOrder=PDOSOrder.sort_values(by=['CF%'],ascending=[0])
PDOSV=PDOSOrder.loc[:,'PDO']
SCFV=SCFOrder.loc[:,'CF%']/100
SGOL=PDOSOrder.loc[:,'GF%']
STAS=DFSITFilter.loc[:,'FA']
STAHDG=DFSITFilter.loc[:,'HDGF%']
SGAW=DFSITFilter.loc[:,'GA']
SSB=DFSITFilter.loc[:,'On-Ice SV%']
STOI=DFSITFilter.loc[:,'TOI']/100
SPRS=PDOSOrder.loc[:,'Player']
EXSRPRS=DFSITFilter.loc[:,'Player']
OSP=pd.DataFrame(DFSITFilter['Player'])</code></pre>
<pre><code>fig, (ax1,ax2) = plt.subplots(1, 2, figsize=(10, 5))
plt.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.4)
for ax in fig.axes:
    plt.sca(ax)
    plt.xticks(rotation=90)
ax1.scatter(SPRS,PDOSV,color='purple')
ax1.scatter(SPRS,SCFV)
ax1.legend(['Goals','high Danger Goals'])
ax1.title.set_text('PDO and CF')

ax2.scatter(EXSRPRS,SSB,color='red')
ax2.scatter(EXSRPRS,STAHDG,color='black')
ax2.scatter(EXSRPRS,STOI,color='green')
ax2.title.set_text('On-Ice SV%, HDGF%, and TOI')
ax2.legend(['On-Ice SV%','HDGF%','TOI (x100)'])
plt.show()</code></pre>
</section>
<section id="now-it-comes-time-to-make-my-picks-for-the-hart-memorial-trophy.-the-list-is-as-follows" class="level1">
<h1>Now it comes time to make my picks for the Hart Memorial Trophy. The list is as follows:</h1>
</section>
<section id="connor-hellbuyck" class="level1">
<h1>1) Connor Hellbuyck</h1>
</section>
<section id="zach-weresnki" class="level1">
<h1>2) Zach Weresnki</h1>
</section>
<section id="kirill-marchenko-1" class="level1">
<h1>3) Kirill Marchenko</h1>
</section>
<section id="dustin-wolf-2" class="level1">
<h1>4) Dustin Wolf</h1>
</section>
<section id="john-carlson-2" class="level1">
<h1>5) John Carlson</h1>
<p>Lastly comes the Lady Byng trophy given to the athlete who displays the best sportsmanship and skills. Information related to skill is going to be pulled from the Hart Memorial Trophy visualizations above, but for sportsmanship the primary metrics being looked at will be penalties incurred by skaters.</p>
<pre><code>RPEN=pd.read_csv("RookieSkaterIndividual.csv",usecols=['Player','TOI','PIM','Total Penalties','Minor','Major','Misconduct','Penalties Drawn'])
SPEN=pd.read_csv("SkaterIndividualstats.csv",usecols=['Player','TOI','PIM','Total Penalties','Minor','Major','Misconduct','Penalties Drawn'])
SPEN.sort_values(by=['Major'],ascending=[1])
SPENFilter=SPEN[SPEN['TOI']&gt;1400]
display(SPENFilter)
SPPS=SPENFilter.loc[:,'Player']
SPIM=SPENFilter.loc[:,'PIM']
STP=SPENFilter.loc[:,'Total Penalties']
SMI=SPENFilter.loc[:,'Minor']
SMJ=SPENFilter.loc[:,'Major']
SMC=SPENFilter.loc[:,'Misconduct']
SPD=SPENFilter.loc[:,'Penalties Drawn']
SPENT=SPIM+STP+SMI+SMJ+SMC+SPD
SPENT1=pd.DataFrame(SPENT)
SPPS1=pd.DataFrame(SPPS)
AG=pd.concat([SPENT,SPPS],ignore_index=[1])
SPPS1['SPENT1']=SPENT1
SPPS1.sort_values(by=['SPENT1'],ascending=[1])</code></pre>
<p>The players with the best sportmanship will have the lowest SPENT1 values above. The problem is that there are tons of them with a score of 0. I then sorted by TOI with a minimum TOI of 1500 required. From here I looked at more seasoned players who were in the above nominations. These include Cale Makar, Erik Karlsson, John Carlson, and Zach Werenski. Next will come the rookies.</p>
<pre><code>RPENFilter=RPEN[RPEN['TOI']&gt;1000]
display(RPENFilter)
RPPS=RPENFilter.loc[:,'Player']
RPIM=RPENFilter.loc[:,'PIM']
RTP=RPENFilter.loc[:,'Total Penalties']
RMI=RPENFilter.loc[:,'Minor']
RMJ=RPENFilter.loc[:,'Major']
RMC=RPENFilter.loc[:,'Misconduct']
RPD=RPENFilter.loc[:,'Penalties Drawn']
RPENT=RPIM+RTP+RMI+RMJ+RMC+RPD
RPENT1=pd.DataFrame(RPENT)
RPPS1=pd.DataFrame(RPPS)
RG=pd.concat([RPENT,RPPS],ignore_index=[1])
RPPS1['RPENT1']=RPENT1
RPPS1.sort_values(by=['RPENT1'],ascending=[1])</code></pre>
<pre><code>Cale=42
Erik=43
John=43
Zach=68
Alex=25
Wyatt=34
Kirill=41</code></pre>
<p>Some names seen previously include Alex Vlasic, Wyatt Johnston, and Kirill Marchenko. Next comes time to compare these players specifically. Interestingly enough the rookies have lower incursion scores which is the sum of major and minor penalties, penalties drawn, PIM, total penalties, and misconduct.</p>
</section>
<section id="my-list-for-the-lady-byng-trophy-is-as-follows" class="level1">
<h1>My list for the Lady Byng Trophy is as follows:</h1>
</section>
<section id="cale-makar-1" class="level1">
<h1>1) Cale Makar</h1>
</section>
<section id="kirill-marchenko-2" class="level1">
<h1>2) Kirill Marchenko</h1>
</section>
<section id="alex-vlasic-1" class="level1">
<h1>3) Alex Vlasic</h1>
</section>
<section id="erik-karlsson-1" class="level1">
<h1>4) Erik Karlsson</h1>
</section>
<section id="john-carlson-3" class="level1">
<h1>5) John Carlson</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/www\.Baden520\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>